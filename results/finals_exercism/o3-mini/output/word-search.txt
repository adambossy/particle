=== Initial Source Code ===
Source file: exercises/practice/word-search/.meta/example.py
import copy


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'Point({self.x}:{self.y})'

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Point(self.x - other.x, self.y - other.y)

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __ne__(self, other):
        return not self == other


DIRECTIONS = (Point(1, 0), Point(1, -1), Point(1, 1), Point(-1, -1),
              Point(0, -1), Point(0, 1), Point(-1, 1), Point(-1, 0))


class WordSearch:
    def __init__(self, puzzle):
        self.rows = puzzle
        self.width = len(self.rows[0])
        self.height = len(self.rows)

    def find_char(self, coordinate):
        if coordinate.x < 0 or coordinate.x >= self.width:
            return None
        if coordinate.y < 0 or coordinate.y >= self.height:
            return None
        return self.rows[coordinate.y][coordinate.x]

    def find(self, word, position, direction):
        current = copy.copy(position)
        for letter in word:
            if self.find_char(current) != letter:
                return None
            current += direction
        return position, current - direction

    def search(self, word):
        positions = (Point(idx, edx)
                     for idx in range(self.width) for edx in range(self.height))
        for position in positions:
            for direction in DIRECTIONS:
                result = self.find(word, position, direction)
                if result:
                    return result
        return None


=== Source Interface ===
class Point:
    def __init__(self, x, y):
        self.x = None
        self.y = None

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y


class WordSearch:
    def __init__(self, puzzle):
        pass

    def search(self, word):
        pass


=== Target Interface ===
package wordsearch

func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	panic("Please implement the Solve function")
}


=== Source Test Code ===
# These tests are auto-generated with test data from:
# https://github.com/exercism/problem-specifications/tree/main/exercises/word-search/canonical-data.json
# File last updated on 2023-07-19

import unittest

from word_search import (
    WordSearch,
    Point,
)


class WordSearchTest(unittest.TestCase):
    def test_should_accept_an_initial_game_grid_and_a_target_search_word(self):
        puzzle = WordSearch(["jefblpepre"])
        self.assertIsNone(puzzle.search("clojure"))

    def test_should_locate_one_word_written_left_to_right(self):
        puzzle = WordSearch(["clojurermt"])
        self.assertEqual(puzzle.search("clojure"), (Point(0, 0), Point(6, 0)))

    def test_should_locate_the_same_word_written_left_to_right_in_a_different_position(
        self,
    ):
        puzzle = WordSearch(["mtclojurer"])
        self.assertEqual(puzzle.search("clojure"), (Point(2, 0), Point(8, 0)))

    def test_should_locate_a_different_left_to_right_word(self):
        puzzle = WordSearch(["coffeelplx"])
        self.assertEqual(puzzle.search("coffee"), (Point(0, 0), Point(5, 0)))

    def test_should_locate_that_different_left_to_right_word_in_a_different_position(
        self,
    ):
        puzzle = WordSearch(["xcoffeezlp"])
        self.assertEqual(puzzle.search("coffee"), (Point(1, 0), Point(6, 0)))

    def test_should_locate_a_left_to_right_word_in_two_line_grid(self):
        puzzle = WordSearch(["jefblpepre", "tclojurerm"])
        self.assertEqual(puzzle.search("clojure"), (Point(1, 1), Point(7, 1)))

    def test_should_locate_a_left_to_right_word_in_three_line_grid(self):
        puzzle = WordSearch(["camdcimgtc", "jefblpepre", "clojurermt"])
        self.assertEqual(puzzle.search("clojure"), (Point(0, 2), Point(6, 2)))

    def test_should_locate_a_left_to_right_word_in_ten_line_grid(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))

    def test_should_locate_that_left_to_right_word_in_a_different_position_in_a_ten_line_grid(
        self,
    ):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "clojurermt",
                "jalaycalmp",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 8), Point(6, 8)))

    def test_should_locate_a_different_left_to_right_word_in_a_ten_line_grid(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "fortranftw",
                "alxhpburyi",
                "clojurermt",
                "jalaycalmp",
            ]
        )
        self.assertEqual(puzzle.search("fortran"), (Point(0, 6), Point(6, 6)))

    def test_should_locate_multiple_words(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "fortranftw",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("fortran"), (Point(0, 6), Point(6, 6)))
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))

    def test_should_locate_a_single_word_written_right_to_left(self):
        puzzle = WordSearch(["rixilelhrs"])
        self.assertEqual(puzzle.search("elixir"), (Point(5, 0), Point(0, 0)))

    def test_should_locate_multiple_words_written_in_different_horizontal_directions(
        self,
    ):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("elixir"), (Point(5, 4), Point(0, 4)))
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))

    def test_should_locate_words_written_top_to_bottom(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))
        self.assertEqual(puzzle.search("elixir"), (Point(5, 4), Point(0, 4)))
        self.assertEqual(puzzle.search("ecmascript"), (Point(9, 0), Point(9, 9)))

    def test_should_locate_words_written_bottom_to_top(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))
        self.assertEqual(puzzle.search("elixir"), (Point(5, 4), Point(0, 4)))
        self.assertEqual(puzzle.search("ecmascript"), (Point(9, 0), Point(9, 9)))
        self.assertEqual(puzzle.search("rust"), (Point(8, 4), Point(8, 1)))

    def test_should_locate_words_written_top_left_to_bottom_right(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))
        self.assertEqual(puzzle.search("elixir"), (Point(5, 4), Point(0, 4)))
        self.assertEqual(puzzle.search("ecmascript"), (Point(9, 0), Point(9, 9)))
        self.assertEqual(puzzle.search("rust"), (Point(8, 4), Point(8, 1)))
        self.assertEqual(puzzle.search("java"), (Point(0, 0), Point(3, 3)))

    def test_should_locate_words_written_bottom_right_to_top_left(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))
        self.assertEqual(puzzle.search("elixir"), (Point(5, 4), Point(0, 4)))
        self.assertEqual(puzzle.search("ecmascript"), (Point(9, 0), Point(9, 9)))
        self.assertEqual(puzzle.search("rust"), (Point(8, 4), Point(8, 1)))
        self.assertEqual(puzzle.search("java"), (Point(0, 0), Point(3, 3)))
        self.assertEqual(puzzle.search("lua"), (Point(7, 8), Point(5, 6)))

    def test_should_locate_words_written_bottom_left_to_top_right(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))
        self.assertEqual(puzzle.search("elixir"), (Point(5, 4), Point(0, 4)))
        self.assertEqual(puzzle.search("ecmascript"), (Point(9, 0), Point(9, 9)))
        self.assertEqual(puzzle.search("rust"), (Point(8, 4), Point(8, 1)))
        self.assertEqual(puzzle.search("java"), (Point(0, 0), Point(3, 3)))
        self.assertEqual(puzzle.search("lua"), (Point(7, 8), Point(5, 6)))
        self.assertEqual(puzzle.search("lisp"), (Point(2, 5), Point(5, 2)))

    def test_should_locate_words_written_top_right_to_bottom_left(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))
        self.assertEqual(puzzle.search("elixir"), (Point(5, 4), Point(0, 4)))
        self.assertEqual(puzzle.search("ecmascript"), (Point(9, 0), Point(9, 9)))
        self.assertEqual(puzzle.search("rust"), (Point(8, 4), Point(8, 1)))
        self.assertEqual(puzzle.search("java"), (Point(0, 0), Point(3, 3)))
        self.assertEqual(puzzle.search("lua"), (Point(7, 8), Point(5, 6)))
        self.assertEqual(puzzle.search("lisp"), (Point(2, 5), Point(5, 2)))
        self.assertEqual(puzzle.search("ruby"), (Point(7, 5), Point(4, 8)))

    def test_should_fail_to_locate_a_word_that_is_not_in_the_puzzle(self):
        puzzle = WordSearch(
            [
                "jefblpepre",
                "camdcimgtc",
                "oivokprjsm",
                "pbwasqroua",
                "rixilelhrs",
                "wolcqlirpc",
                "screeaumgr",
                "alxhpburyi",
                "jalaycalmp",
                "clojurermt",
            ]
        )
        self.assertEqual(puzzle.search("clojure"), (Point(0, 9), Point(6, 9)))
        self.assertEqual(puzzle.search("elixir"), (Point(5, 4), Point(0, 4)))
        self.assertEqual(puzzle.search("ecmascript"), (Point(9, 0), Point(9, 9)))
        self.assertEqual(puzzle.search("rust"), (Point(8, 4), Point(8, 1)))
        self.assertEqual(puzzle.search("java"), (Point(0, 0), Point(3, 3)))
        self.assertEqual(puzzle.search("lua"), (Point(7, 8), Point(5, 6)))
        self.assertEqual(puzzle.search("lisp"), (Point(2, 5), Point(5, 2)))
        self.assertEqual(puzzle.search("ruby"), (Point(7, 5), Point(4, 8)))
        self.assertIsNone(puzzle.search("haskell"))

    def test_should_fail_to_locate_words_that_are_not_on_horizontal_vertical_or_diagonal_lines(
        self,
    ):
        puzzle = WordSearch(["abc", "def"])
        self.assertIsNone(puzzle.search("aef"))
        self.assertIsNone(puzzle.search("ced"))
        self.assertIsNone(puzzle.search("abf"))
        self.assertIsNone(puzzle.search("cbd"))

    def test_should_not_concatenate_different_lines_to_find_a_horizontal_word(self):
        puzzle = WordSearch(["abceli", "xirdfg"])
        self.assertIsNone(puzzle.search("elixir"))

    def test_should_not_wrap_around_horizontally_to_find_a_word(self):
        puzzle = WordSearch(["silabcdefp"])
        self.assertIsNone(puzzle.search("lisp"))

    def test_should_not_wrap_around_vertically_to_find_a_word(self):
        puzzle = WordSearch(["s", "u", "r", "a", "b", "c", "t"])
        self.assertIsNone(puzzle.search("rust"))


=== Target Test Code ===
package wordsearch

import (
	"reflect"
	"testing"
)

func TestSolve(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual, err := Solve(tc.words, tc.puzzle)
			switch {
			case tc.expectError:
				if err == nil {
					t.Fatalf("Solve(%v,%v) expected error, got:%v", tc.words, tc.puzzle, actual)
				}
			case err != nil:
				t.Fatalf("Solve(%v,%v) returned error: %v, want:%v", tc.words, tc.puzzle, err, tc.expected)
			case !reflect.DeepEqual(actual, tc.expected):
				t.Fatalf("Solve(%v,%v) = %v, want:%v", tc.words, tc.puzzle, actual, tc.expected)
			}
		})
	}
}

func BenchmarkSolve(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			Solve(tc.words, tc.puzzle)
		}
	}
}


=== Initial Translation ===
// exercises/practice/word-search/.meta/example.go
package meta

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates.
// This struct implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0},  {1, -1}, {1, 1},  {-1, -1},
	{0, -1}, {0, 1},  {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// or false if the coordinate is out of bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Initial Test Results ===
Return code: 1
=== STDOUT ===

=== STDERR ===
found packages meta (word_search.go) and wordsearch (word_search_test.go) in /private/var/folders/gy/0zbg6hg95tq8_gy1dnr3tknm0000gn/T/tmpt_h86ptc/sandbox/exercises/practice/word-search


=== Retry Attempt 1 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 1) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 2 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 2) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 3 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 3) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 4 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 4) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 5 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 5) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 6 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 6) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 7 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 7) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 8 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 8) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 9 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}


=== Test Results (Attempt 9) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search_test.go:9:21: undefined: testCases
./word_search_test.go:31:22: undefined: testCases


=== Retry Attempt 10 ===
// exercises/practice/word-search/.meta/example.go
package wordsearch

import (
	"fmt"
)

// Point represents a coordinate in the puzzle grid.
// It holds X and Y coordinates and implements basic arithmetic and comparison operations.

type Point struct {
	X int
	Y int
}

// String returns a string representation of the Point.
func (p Point) String() string {
	return fmt.Sprintf("Point(%d:%d)", p.X, p.Y)
}

// Add returns a new Point by adding the coordinates of another Point.
func (p Point) Add(other Point) Point {
	return Point{X: p.X + other.X, Y: p.Y + other.Y}
}

// Sub returns a new Point by subtracting the coordinates of another Point.
func (p Point) Sub(other Point) Point {
	return Point{X: p.X - other.X, Y: p.Y - other.Y}
}

// Equal checks if two Points have the same coordinates.
func (p Point) Equal(other Point) bool {
	return p.X == other.X && p.Y == other.Y
}

// DIRECTIONS holds the 8 possible directions for word search.
var DIRECTIONS = []Point{
	{1, 0}, {1, -1}, {1, 1}, {-1, -1},
	{0, -1}, {0, 1}, {-1, 1}, {-1, 0},
}

// WordSearch represents a word search puzzle.
// It holds the puzzle rows and calculates its dimensions.

type WordSearch struct {
	rows   []string
	width  int
	height int
}

// NewWordSearch creates a new WordSearch instance given a puzzle.
func NewWordSearch(puzzle []string) *WordSearch {
	if len(puzzle) == 0 {
		return &WordSearch{rows: puzzle, width: 0, height: 0}
	}
	return &WordSearch{
		rows:   puzzle,
		width:  len(puzzle[0]),
		height: len(puzzle),
	}
}

// findChar returns the character at a given coordinate in the puzzle,
// along with a boolean indicating whether the coordinate is within bounds.
func (ws *WordSearch) findChar(coordinate Point) (byte, bool) {
	if coordinate.X < 0 || coordinate.X >= ws.width {
		return 0, false
	}
	if coordinate.Y < 0 || coordinate.Y >= ws.height {
		return 0, false
	}
	return ws.rows[coordinate.Y][coordinate.X], true
}

// find attempts to find the given word starting at position and moving in the given direction.
// If found, it returns the start and end Points along with true; otherwise, false.
func (ws *WordSearch) find(word string, position, direction Point) (Point, Point, bool) {
	current := position
	for i := 0; i < len(word); i++ {
		c, ok := ws.findChar(current)
		if !ok || c != word[i] {
			return Point{}, Point{}, false
		}
		current = current.Add(direction)
	}
	// The last valid letter position is one step back.
	end := current.Sub(direction)
	return position, end, true
}

// Search looks for the word in the puzzle, returning the start and end Points if found.
// If not found, it returns false.
func (ws *WordSearch) Search(word string) (Point, Point, bool) {
	for x := 0; x < ws.width; x++ {
		for y := 0; y < ws.height; y++ {
			pos := Point{X: x, Y: y}
			for _, dir := range DIRECTIONS {
				start, end, found := ws.find(word, pos, dir)
				if found {
					return start, end, true
				}
			}
		}
	}
	return Point{}, Point{}, false
}

// Solve finds all the words in the given puzzle and returns their coordinates.
// The return value is a map where each key is a word and its value is a 2x2 array of ints,
// representing the starting [x, y] and ending [x, y] coordinates of the word.
// If a word cannot be found in the puzzle, it is omitted from the result.
func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {
	ws := NewWordSearch(puzzle)
	result := make(map[string][2][2]int)
	for _, word := range words {
		start, end, found := ws.Search(word)
		if found {
			result[word] = [2][2]int{{start.X, start.Y}, {end.X, end.Y}}
		}
	}
	return result, nil
}

// exercises/practice/word-search/word_search_test.go
package wordsearch

import (
	"reflect"
	"testing"
)

// testCase represents a single test scenario for the Solve function.
// description: short description of the test case
// words: slice of words to search for
// puzzle: the word search puzzle represented as a slice of strings (each string is a row)
// expected: expected output as a map from word to its start and end coordinates
// expectError: whether an error is expected

type testCase struct {
	description string
	words       []string
	puzzle      []string
	expected    map[string][2][2]int
	expectError bool
}

var testCases = []testCase{
	{
		description: "Simple horizontal and vertical words",
		words:       []string{"ABC", "ADG"},
		puzzle: []string{
			"ABC",
			"DEF",
			"GHI",
		},
		expected: map[string][2][2]int{
			"ABC": {{0, 0}, {2, 0}},
			"ADG": {{0, 0}, {0, 2}},
		},
		expectError: false,
	},
	{
		description: "Word not found",
		words:       []string{"XYZ"},
		puzzle: []string{
			"ABC",
			"DEF",
			"GHI",
		},
		expected:    map[string][2][2]int{},
		expectError: false,
	},
	{
		description: "Diagonal word",
		words:       []string{"AEI"},
		puzzle: []string{
			"ABC",
			"DEF",
			"GHI",
		},
		expected: map[string][2][2]int{
			"AEI": {{0, 0}, {2, 2}},
		},
		expectError: false,
	},
}

func TestSolve(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual, err := Solve(tc.words, tc.puzzle)
			switch {
			case tc.expectError:
				if err == nil {
					t.Fatalf("Solve(%v, %v) expected error, got: %v", tc.words, tc.puzzle, actual)
				}
			case err != nil:
				t.Fatalf("Solve(%v, %v) returned error: %v, want: %v", tc.words, tc.puzzle, err, tc.expected)
			case !reflect.DeepEqual(actual, tc.expected):
				t.Fatalf("Solve(%v, %v) = %v, want: %v", tc.words, tc.puzzle, actual, tc.expected)
			}
		})
	}
}

func BenchmarkSolve(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			Solve(tc.words, tc.puzzle)
		}
	}
}


=== Test Results (Attempt 10) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/word-search [build failed]
FAIL

=== STDERR ===
# exercism/word-search [exercism/word-search.test]
./word_search.go:125:1: syntax error: non-declaration statement outside function body


=== FINAL STATUS: FAILED ===