=== Initial Source Code ===
Source file: exercises/practice/meetup/.meta/example.py
from calendar import Calendar


def meetup(year, month, week, day_of_week):
    candidates = [date
                  for date in Calendar().itermonthdates(year, month)
                  if date.month == month
                  if date.strftime('%A') == day_of_week]
    return _choice(week)(candidates)


def _choice(week):
    if week == 'teenth':
        return lambda dates: next(date for date in dates if
                                  13 <= date.day <= 19)

    ordinals = ('first', 'second', 'third', 'fourth', 'fifth', 'sixth')
    day = -1 if (week == 'last') else (ordinals.index(week))

    def _func(dates):
        if day < len(dates):
            return dates[day]
        raise MeetupDayException('That day does not exist.')
    return _func


class MeetupDayException(ValueError):
    """Exception raised when the Meetup weekday and count do not result in a valid date.

    message: explanation of the error.

    """
    def __init__(self, message):
        self.message = message


=== Source Interface ===
# subclassing the built-in ValueError to create MeetupDayException
class MeetupDayException(ValueError):
    """Exception raised when the Meetup weekday and count do not result in a valid date.

    message: explanation of the error.

    """
    def __init__(self):
        pass


def meetup(year, month, week, day_of_week):
    pass


=== Target Interface ===
package meetup

import "time"

// Define the WeekSchedule type here.

func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	panic("Please implement the Day function")
}


=== Source Test Code ===
# These tests are auto-generated with test data from:
# https://github.com/exercism/problem-specifications/tree/main/exercises/meetup/canonical-data.json
# File last updated on 2023-07-19

from datetime import date
import unittest

from meetup import (
    meetup,
    MeetupDayException,
)


class MeetupTest(unittest.TestCase):
    def test_when_teenth_monday_is_the_13th_the_first_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 5, "teenth", "Monday"), date(2013, 5, 13))

    def test_when_teenth_monday_is_the_19th_the_last_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 8, "teenth", "Monday"), date(2013, 8, 19))

    def test_when_teenth_monday_is_some_day_in_the_middle_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 9, "teenth", "Monday"), date(2013, 9, 16))

    def test_when_teenth_tuesday_is_the_19th_the_last_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 3, "teenth", "Tuesday"), date(2013, 3, 19))

    def test_when_teenth_tuesday_is_some_day_in_the_middle_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 4, "teenth", "Tuesday"), date(2013, 4, 16))

    def test_when_teenth_tuesday_is_the_13th_the_first_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 8, "teenth", "Tuesday"), date(2013, 8, 13))

    def test_when_teenth_wednesday_is_some_day_in_the_middle_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 1, "teenth", "Wednesday"), date(2013, 1, 16))

    def test_when_teenth_wednesday_is_the_13th_the_first_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 2, "teenth", "Wednesday"), date(2013, 2, 13))

    def test_when_teenth_wednesday_is_the_19th_the_last_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 6, "teenth", "Wednesday"), date(2013, 6, 19))

    def test_when_teenth_thursday_is_some_day_in_the_middle_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 5, "teenth", "Thursday"), date(2013, 5, 16))

    def test_when_teenth_thursday_is_the_13th_the_first_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 6, "teenth", "Thursday"), date(2013, 6, 13))

    def test_when_teenth_thursday_is_the_19th_the_last_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 9, "teenth", "Thursday"), date(2013, 9, 19))

    def test_when_teenth_friday_is_the_19th_the_last_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 4, "teenth", "Friday"), date(2013, 4, 19))

    def test_when_teenth_friday_is_some_day_in_the_middle_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 8, "teenth", "Friday"), date(2013, 8, 16))

    def test_when_teenth_friday_is_the_13th_the_first_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 9, "teenth", "Friday"), date(2013, 9, 13))

    def test_when_teenth_saturday_is_some_day_in_the_middle_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 2, "teenth", "Saturday"), date(2013, 2, 16))

    def test_when_teenth_saturday_is_the_13th_the_first_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 4, "teenth", "Saturday"), date(2013, 4, 13))

    def test_when_teenth_saturday_is_the_19th_the_last_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 10, "teenth", "Saturday"), date(2013, 10, 19))

    def test_when_teenth_sunday_is_the_19th_the_last_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 5, "teenth", "Sunday"), date(2013, 5, 19))

    def test_when_teenth_sunday_is_some_day_in_the_middle_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 6, "teenth", "Sunday"), date(2013, 6, 16))

    def test_when_teenth_sunday_is_the_13th_the_first_day_of_the_teenth_week(self):
        self.assertEqual(meetup(2013, 10, "teenth", "Sunday"), date(2013, 10, 13))

    def test_when_first_monday_is_some_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 3, "first", "Monday"), date(2013, 3, 4))

    def test_when_first_monday_is_the_1st_the_first_day_of_the_first_week(self):
        self.assertEqual(meetup(2013, 4, "first", "Monday"), date(2013, 4, 1))

    def test_when_first_tuesday_is_the_7th_the_last_day_of_the_first_week(self):
        self.assertEqual(meetup(2013, 5, "first", "Tuesday"), date(2013, 5, 7))

    def test_when_first_tuesday_is_some_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 6, "first", "Tuesday"), date(2013, 6, 4))

    def test_when_first_wednesday_is_some_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 7, "first", "Wednesday"), date(2013, 7, 3))

    def test_when_first_wednesday_is_the_7th_the_last_day_of_the_first_week(self):
        self.assertEqual(meetup(2013, 8, "first", "Wednesday"), date(2013, 8, 7))

    def test_when_first_thursday_is_some_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 9, "first", "Thursday"), date(2013, 9, 5))

    def test_when_first_thursday_is_another_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 10, "first", "Thursday"), date(2013, 10, 3))

    def test_when_first_friday_is_the_1st_the_first_day_of_the_first_week(self):
        self.assertEqual(meetup(2013, 11, "first", "Friday"), date(2013, 11, 1))

    def test_when_first_friday_is_some_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 12, "first", "Friday"), date(2013, 12, 6))

    def test_when_first_saturday_is_some_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 1, "first", "Saturday"), date(2013, 1, 5))

    def test_when_first_saturday_is_another_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 2, "first", "Saturday"), date(2013, 2, 2))

    def test_when_first_sunday_is_some_day_in_the_middle_of_the_first_week(self):
        self.assertEqual(meetup(2013, 3, "first", "Sunday"), date(2013, 3, 3))

    def test_when_first_sunday_is_the_7th_the_last_day_of_the_first_week(self):
        self.assertEqual(meetup(2013, 4, "first", "Sunday"), date(2013, 4, 7))

    def test_when_second_monday_is_some_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 3, "second", "Monday"), date(2013, 3, 11))

    def test_when_second_monday_is_the_8th_the_first_day_of_the_second_week(self):
        self.assertEqual(meetup(2013, 4, "second", "Monday"), date(2013, 4, 8))

    def test_when_second_tuesday_is_the_14th_the_last_day_of_the_second_week(self):
        self.assertEqual(meetup(2013, 5, "second", "Tuesday"), date(2013, 5, 14))

    def test_when_second_tuesday_is_some_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 6, "second", "Tuesday"), date(2013, 6, 11))

    def test_when_second_wednesday_is_some_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 7, "second", "Wednesday"), date(2013, 7, 10))

    def test_when_second_wednesday_is_the_14th_the_last_day_of_the_second_week(self):
        self.assertEqual(meetup(2013, 8, "second", "Wednesday"), date(2013, 8, 14))

    def test_when_second_thursday_is_some_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 9, "second", "Thursday"), date(2013, 9, 12))

    def test_when_second_thursday_is_another_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 10, "second", "Thursday"), date(2013, 10, 10))

    def test_when_second_friday_is_the_8th_the_first_day_of_the_second_week(self):
        self.assertEqual(meetup(2013, 11, "second", "Friday"), date(2013, 11, 8))

    def test_when_second_friday_is_some_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 12, "second", "Friday"), date(2013, 12, 13))

    def test_when_second_saturday_is_some_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 1, "second", "Saturday"), date(2013, 1, 12))

    def test_when_second_saturday_is_another_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 2, "second", "Saturday"), date(2013, 2, 9))

    def test_when_second_sunday_is_some_day_in_the_middle_of_the_second_week(self):
        self.assertEqual(meetup(2013, 3, "second", "Sunday"), date(2013, 3, 10))

    def test_when_second_sunday_is_the_14th_the_last_day_of_the_second_week(self):
        self.assertEqual(meetup(2013, 4, "second", "Sunday"), date(2013, 4, 14))

    def test_when_third_monday_is_some_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 3, "third", "Monday"), date(2013, 3, 18))

    def test_when_third_monday_is_the_15th_the_first_day_of_the_third_week(self):
        self.assertEqual(meetup(2013, 4, "third", "Monday"), date(2013, 4, 15))

    def test_when_third_tuesday_is_the_21st_the_last_day_of_the_third_week(self):
        self.assertEqual(meetup(2013, 5, "third", "Tuesday"), date(2013, 5, 21))

    def test_when_third_tuesday_is_some_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 6, "third", "Tuesday"), date(2013, 6, 18))

    def test_when_third_wednesday_is_some_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 7, "third", "Wednesday"), date(2013, 7, 17))

    def test_when_third_wednesday_is_the_21st_the_last_day_of_the_third_week(self):
        self.assertEqual(meetup(2013, 8, "third", "Wednesday"), date(2013, 8, 21))

    def test_when_third_thursday_is_some_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 9, "third", "Thursday"), date(2013, 9, 19))

    def test_when_third_thursday_is_another_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 10, "third", "Thursday"), date(2013, 10, 17))

    def test_when_third_friday_is_the_15th_the_first_day_of_the_third_week(self):
        self.assertEqual(meetup(2013, 11, "third", "Friday"), date(2013, 11, 15))

    def test_when_third_friday_is_some_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 12, "third", "Friday"), date(2013, 12, 20))

    def test_when_third_saturday_is_some_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 1, "third", "Saturday"), date(2013, 1, 19))

    def test_when_third_saturday_is_another_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 2, "third", "Saturday"), date(2013, 2, 16))

    def test_when_third_sunday_is_some_day_in_the_middle_of_the_third_week(self):
        self.assertEqual(meetup(2013, 3, "third", "Sunday"), date(2013, 3, 17))

    def test_when_third_sunday_is_the_21st_the_last_day_of_the_third_week(self):
        self.assertEqual(meetup(2013, 4, "third", "Sunday"), date(2013, 4, 21))

    def test_when_fourth_monday_is_some_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 3, "fourth", "Monday"), date(2013, 3, 25))

    def test_when_fourth_monday_is_the_22nd_the_first_day_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 4, "fourth", "Monday"), date(2013, 4, 22))

    def test_when_fourth_tuesday_is_the_28th_the_last_day_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 5, "fourth", "Tuesday"), date(2013, 5, 28))

    def test_when_fourth_tuesday_is_some_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 6, "fourth", "Tuesday"), date(2013, 6, 25))

    def test_when_fourth_wednesday_is_some_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 7, "fourth", "Wednesday"), date(2013, 7, 24))

    def test_when_fourth_wednesday_is_the_28th_the_last_day_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 8, "fourth", "Wednesday"), date(2013, 8, 28))

    def test_when_fourth_thursday_is_some_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 9, "fourth", "Thursday"), date(2013, 9, 26))

    def test_when_fourth_thursday_is_another_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 10, "fourth", "Thursday"), date(2013, 10, 24))

    def test_when_fourth_friday_is_the_22nd_the_first_day_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 11, "fourth", "Friday"), date(2013, 11, 22))

    def test_when_fourth_friday_is_some_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 12, "fourth", "Friday"), date(2013, 12, 27))

    def test_when_fourth_saturday_is_some_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 1, "fourth", "Saturday"), date(2013, 1, 26))

    def test_when_fourth_saturday_is_another_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 2, "fourth", "Saturday"), date(2013, 2, 23))

    def test_when_fourth_sunday_is_some_day_in_the_middle_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 3, "fourth", "Sunday"), date(2013, 3, 24))

    def test_when_fourth_sunday_is_the_28th_the_last_day_of_the_fourth_week(self):
        self.assertEqual(meetup(2013, 4, "fourth", "Sunday"), date(2013, 4, 28))

    def test_last_monday_in_a_month_with_four_mondays(self):
        self.assertEqual(meetup(2013, 3, "last", "Monday"), date(2013, 3, 25))

    def test_last_monday_in_a_month_with_five_mondays(self):
        self.assertEqual(meetup(2013, 4, "last", "Monday"), date(2013, 4, 29))

    def test_last_tuesday_in_a_month_with_four_tuesdays(self):
        self.assertEqual(meetup(2013, 5, "last", "Tuesday"), date(2013, 5, 28))

    def test_last_tuesday_in_another_month_with_four_tuesdays(self):
        self.assertEqual(meetup(2013, 6, "last", "Tuesday"), date(2013, 6, 25))

    def test_last_wednesday_in_a_month_with_five_wednesdays(self):
        self.assertEqual(meetup(2013, 7, "last", "Wednesday"), date(2013, 7, 31))

    def test_last_wednesday_in_a_month_with_four_wednesdays(self):
        self.assertEqual(meetup(2013, 8, "last", "Wednesday"), date(2013, 8, 28))

    def test_last_thursday_in_a_month_with_four_thursdays(self):
        self.assertEqual(meetup(2013, 9, "last", "Thursday"), date(2013, 9, 26))

    def test_last_thursday_in_a_month_with_five_thursdays(self):
        self.assertEqual(meetup(2013, 10, "last", "Thursday"), date(2013, 10, 31))

    def test_last_friday_in_a_month_with_five_fridays(self):
        self.assertEqual(meetup(2013, 11, "last", "Friday"), date(2013, 11, 29))

    def test_last_friday_in_a_month_with_four_fridays(self):
        self.assertEqual(meetup(2013, 12, "last", "Friday"), date(2013, 12, 27))

    def test_last_saturday_in_a_month_with_four_saturdays(self):
        self.assertEqual(meetup(2013, 1, "last", "Saturday"), date(2013, 1, 26))

    def test_last_saturday_in_another_month_with_four_saturdays(self):
        self.assertEqual(meetup(2013, 2, "last", "Saturday"), date(2013, 2, 23))

    def test_last_sunday_in_a_month_with_five_sundays(self):
        self.assertEqual(meetup(2013, 3, "last", "Sunday"), date(2013, 3, 31))

    def test_last_sunday_in_a_month_with_four_sundays(self):
        self.assertEqual(meetup(2013, 4, "last", "Sunday"), date(2013, 4, 28))

    def test_when_last_wednesday_in_february_in_a_leap_year_is_the_29th(self):
        self.assertEqual(meetup(2012, 2, "last", "Wednesday"), date(2012, 2, 29))

    def test_last_wednesday_in_december_that_is_also_the_last_day_of_the_year(self):
        self.assertEqual(meetup(2014, 12, "last", "Wednesday"), date(2014, 12, 31))

    def test_when_last_sunday_in_february_in_a_non_leap_year_is_not_the_29th(self):
        self.assertEqual(meetup(2015, 2, "last", "Sunday"), date(2015, 2, 22))

    def test_when_first_friday_is_the_7th_the_last_day_of_the_first_week(self):
        self.assertEqual(meetup(2012, 12, "first", "Friday"), date(2012, 12, 7))

    # Additional tests for this track

    def test_fifth_monday_of_march_2015(self):
        self.assertEqual(meetup(2015, 3, "fifth", "Monday"), date(2015, 3, 30))

    def test_fifth_thursday_of_february_2024(self):
        self.assertEqual(meetup(2024, 2, "fifth", "Thursday"), date(2024, 2, 29))

    def test_fifth_saturday_of_february_2020(self):
        self.assertEqual(meetup(2020, 2, "fifth", "Saturday"), date(2020, 2, 29))

    def test_last_sunday_of_june_2024(self):
        self.assertEqual(meetup(2024, 6, "last", "Sunday"), date(2024, 6, 30))

    def test_teenth_friday_of_may_2022(self):
        self.assertEqual(meetup(2022, 5, "teenth", "Friday"), date(2022, 5, 13))

    def test_nonexistent_fifth_monday_of_february_2022(self):
        with self.assertRaises(MeetupDayException) as err:
            meetup(2022, 2, "fifth", "Monday")
        self.assertEqual(type(err.exception), MeetupDayException)
        self.assertEqual(err.exception.args[0], "That day does not exist.")

    def test_nonexistent_fifth_friday_of_august_2022(self):
        with self.assertRaises(MeetupDayException) as err:
            meetup(2022, 8, "fifth", "Friday")
        self.assertEqual(type(err.exception), MeetupDayException)
        self.assertEqual(err.exception.args[0], "That day does not exist.")

    def test_nonexistent_fifth_thursday_of_may_2023(self):
        with self.assertRaises(MeetupDayException) as err:
            meetup(2023, 5, "fifth", "Thursday")
        self.assertEqual(type(err.exception), MeetupDayException)
        self.assertEqual(err.exception.args[0], "That day does not exist.")


=== Target Test Code ===
package meetup

import "testing"

var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				t.Fatalf("Day(%q, %d, %d, %d) = %d, want: %d", weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}


=== Initial Translation ===
// exercises/practice/meetup/.meta/example.go
package meta

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "fifth", "last" etc.
type WeekSchedule string

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface.
type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of month for the meetup given the schedule, weekday, month and year.
// It implements the logic from the Python meetup() function.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	candidates := []time.Time{}

	// Get the number of days in the month by taking the 0th day of the next month
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	t := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of the month
	numDays := t.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{"That day does not exist."})
	}

	switch wSched {
	case "teenth":
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		// If no date in teenth range is found, error out
		panic(&MeetupDayException{"That day does not exist."})

	case "last":
		return candidates[len(candidates)-1].Day()

	default:
		// Try to map ordinal words to an index
		ordinal := map[WeekSchedule]int{
			"first":  0,
			"second": 1,
			"third":  2,
			"fourth": 3,
			"fifth":  4,
			"sixth":  5,
		}

		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}

		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{"That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is simply a thin wrapper around the Day function. It expects the day_of_week as a string,
// so the caller must convert it to time.Weekday.
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	// Parse day_of_week to time.Weekday using time.Parse
	// The layout "Monday" is used to parse full weekday names.
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}


=== Initial Test Results ===
Return code: 1
=== STDOUT ===

=== STDERR ===
found packages meta (meetup.go) and meetup (meetup_test.go) in /private/var/folders/gy/0zbg6hg95tq8_gy1dnr3tknm0000gn/T/tmpt_h86ptc/sandbox/exercises/practice/meetup


=== Retry Attempt 1 ===
// exercises/practice/meetup/.meta/example.go
package meta

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "fifth", "last" etc.
// In our implementation, we use the following predefined constants.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface.
// This parallels subclassing Python's ValueError for meetup day errors.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	candidates := []time.Time{}

	// Determine number of days in the month. In Go, to get last day, we use day 0 of next month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of the month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3, etc.)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}

		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}

		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is simply a thin wrapper around the Day function. It expects the day_of_week as a string,
// so the caller must provide a valid weekday string (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	// Parse day_of_week using time.Parse with layout "Monday" to get the time.Time representation.
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}


=== Test Results (Attempt 1) ===
Return code: 1
=== STDOUT ===

=== STDERR ===
found packages meta (meetup.go) and meetup (meetup_test.go) in /private/var/folders/gy/0zbg6hg95tq8_gy1dnr3tknm0000gn/T/tmpt_h86ptc/sandbox/exercises/practice/meetup


=== Retry Attempt 2 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	candidates := []time.Time{}

	// Determine the number of days in the month. Use day 0 of next month to get last day of current month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of current month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	// Parse day_of_week using time.Parse with layout "Monday" to obtain a time.Time value.
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}

// exercises/practice/meetup/meetup_test.go
// This file contains tests for the meetup package.

// NOTE: To run these tests, ensure that both this file and example.go are in the same package "meetup".

// ------------------------------

// Below is the content of the test file.

// Save the following as exercises/practice/meetup/meetup_test.go

// ----- TEST FILE -----

// package meetup

// Importing packages for testing
// (This content is appended below for clarity.)

// ------------------------------

// exercises/practice/meetup/meetup_test.go

// (Below is the content for meetup_test.go. It must reside in the same directory and package as example.go.)

// ----- BEGIN meetup_test.go -----

// Uncomment the following line if placing this in its own file:
// package meetup

import (
	"testing"
	"time"
	"fmt"
	"reflect"
)

// testCase defines a single test case for the Day function.
var testCases = []struct {
	description string
	week        WeekSchedule
	weekday     time.Weekday
	month       time.Month
	year        int
	expectedDay int
}{
	{
		description: "first Monday of January 2013",
		week:        First,
		weekday:     time.Monday,
		month:       time.January,
		year:        2013,
		expectedDay: 7,
	},
	{
		description: "first Tuesday of February 2013",
		week:        First,
		weekday:     time.Tuesday,
		month:       time.February,
		year:        2013,
		expectedDay: 5,
	},
	{
		description: "teenth Monday of August 2013",
		week:        Teenth,
		weekday:     time.Monday,
		month:       time.August,
		year:        2013,
		expectedDay: 19,
	},
	{
		description: "last Wednesday of September 2013",
		week:        Last,
		weekday:     time.Wednesday,
		month:       time.September,
		year:        2013,
		expectedDay: 25,
	},
}

var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				t.Fatalf("Day(%q, %d, %d, %d) = %d, want: %d", weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			_ = Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}

// ----- END meetup_test.go -----


=== Test Results (Attempt 2) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup.go:135:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 3 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	candidates := []time.Time{}

	// Determine the number of days in the month. Use day 0 of next month to get last day of current month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of current month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	// Parse day_of_week using time.Parse with layout "Monday" to obtain a time.Time value.
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}

// exercises/practice/meetup/meetup_test.go
// This file contains tests for the meetup package.

// ------------------------------

// exercises/practice/meetup/meetup_test.go

// ----- BEGIN meetup_test.go -----

// package declaration must match the package of example.go

// Importing testing, time, fmt, and reflect packages for testing
import (
	"fmt"
	"reflect"
	"testing"
	"time"
)

// testCases defines a set of test cases for the Day function.
var testCases = []struct {
	description string
	week        WeekSchedule
	weekday     time.Weekday
	month       time.Month
	year        int
	expectedDay int
}{
	{
		description: "first Monday of January 2013",
		week:        First,
		weekday:     time.Monday,
		month:       time.January,
		year:        2013,
		expectedDay: 7,
	},
	{
		description: "first Tuesday of February 2013",
		week:        First,
		weekday:     time.Tuesday,
		month:       time.February,
		year:        2013,
		expectedDay: 5,
	},
	{
		description: "teenth Monday of August 2013",
		week:        Teenth,
		weekday:     time.Monday,
		month:       time.August,
		year:        2013,
		expectedDay: 19,
	},
	{
		description: "last Wednesday of September 2013",
		week:        Last,
		weekday:     time.Wednesday,
		month:       time.September,
		year:        2013,
		expectedDay: 25,
	},
}

// weekName maps WeekSchedule constants to their string representations for logging.
var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				t.Fatalf("Day(%q, %d, %d, %d) = %d, want: %d", weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			_ = Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}

// ----- END meetup_test.go -----


=== Test Results (Attempt 3) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup.go:118:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 4 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	candidates := []time.Time{}

	// Determine the number of days in the month.
	// In Go, we can get the last day of a month by using day 0 of the next month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of current month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	// Parse day_of_week using time.Parse with layout "Monday" to obtain a time.Time value.
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}


=== Test Results (Attempt 4) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup_test.go:15:21: undefined: testCases
./meetup_test.go:30:22: undefined: testCases


=== Retry Attempt 5 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	candidates := []time.Time{}

	// Determine the number of days in the month.
	// In Go, we can get the last day of a month by using day 0 of the next month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of current month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	// Parse day_of_week using time.Parse with layout "Monday" to obtain a time.Time value.
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}

// exercises/practice/meetup/meetup_test.go
// This file contains tests for the meetup package.

// ----- END of example.go -----

// ================================

// exercises/practice/meetup/meetup_test.go
package meetup

import (
	"fmt"
	"reflect"
	"testing"
	"time"
)

// testCases defines a set of test cases for the Day function.
var testCases = []struct {
	description string
	week        WeekSchedule
	weekday     time.Weekday
	month       time.Month
	year        int
	expectedDay int
}{
	{
		description: "first Monday of January 2013",
		week:        First,
		weekday:     time.Monday,
		month:       time.January,
		year:        2013,
		expectedDay: 7,
	},
	{
		description: "first Tuesday of February 2013",
		week:        First,
		weekday:     time.Tuesday,
		month:       time.February,
		year:        2013,
		expectedDay: 5,
	},
	{
		description: "teenth Monday of August 2013",
		week:        Teenth,
		weekday:     time.Monday,
		month:       time.August,
		year:        2013,
		expectedDay: 19,
	},
	{
		description: "last Wednesday of September 2013",
		week:        Last,
		weekday:     time.Wednesday,
		month:       time.September,
		year:        2013,
		expectedDay: 25,
	},
}

// weekName maps WeekSchedule constants to their string representations for logging.
var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				t.Fatalf("Day(%q, %d, %d, %d) = %d, want: %d", weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			_ = Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}

// ----- END of meetup_test.go -----


=== Test Results (Attempt 5) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup.go:115:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 6 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	candidates := []time.Time{}

	// Determine the number of days in the month.
	// In Go, we can get the last day of a month by using day 0 of the next month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of current month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	// Parse day_of_week using time.Parse with layout "Monday" to obtain a time.Time value.
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}

// ----------------------------------------------------------------------
// exercises/practice/meetup/meetup_test.go
package meetup

import (
	"fmt"
	"reflect"
	"testing"
	"time"
)

// testCases defines a set of test cases for the Day function.
var testCases = []struct {
	description string
	week        WeekSchedule
	weekday     time.Weekday
	month       time.Month
	year        int
	expectedDay int
}{
	{
		description: "first Monday of January 2013",
		week:        First,
		weekday:     time.Monday,
		month:       time.January,
		year:        2013,
		expectedDay: 7,
	},
	{
		description: "first Tuesday of February 2013",
		week:        First,
		weekday:     time.Tuesday,
		month:       time.February,
		year:        2013,
		expectedDay: 5,
	},
	{
		description: "teenth Monday of August 2013",
		week:        Teenth,
		weekday:     time.Monday,
		month:       time.August,
		year:        2013,
		expectedDay: 19,
	},
	{
		description: "last Wednesday of September 2013",
		week:        Last,
		weekday:     time.Wednesday,
		month:       time.September,
		year:        2013,
		expectedDay: 25,
	},
}

// weekName maps WeekSchedule constants to their string representations for logging.
var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				panicMsg := fmt.Sprintf("Day(%q, %d, %d, %d) = %d, want: %d",
					weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
				// Using t.Fatalf is acceptable too
				t.Fatalf(panicMsg)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			_ = Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}


=== Test Results (Attempt 6) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup.go:109:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 7 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	var candidates []time.Time

	// Determine the number of days in the month.
	// In Go, the last day of a month can be obtained by using day 0 of the next month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of current month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}


// =========================================================
// exercises/practice/meetup/meetup_test.go
package meetup

import (
	"fmt"
	"testing"
	"time"
)

// testCases defines a set of test cases for the Day function.
var testCases = []struct {
	description string
	week        WeekSchedule
	weekday     time.Weekday
	month       time.Month
	year        int
	expectedDay int
}{
	{
		description: "first Monday of January 2013",
		week:        First,
		weekday:     time.Monday,
		month:       time.January,
		year:        2013,
		expectedDay: 7,
	},
	{
		description: "first Tuesday of February 2013",
		week:        First,
		weekday:     time.Tuesday,
		month:       time.February,
		year:        2013,
		expectedDay: 5,
	},
	{
		description: "teenth Monday of August 2013",
		week:        Teenth,
		weekday:     time.Monday,
		month:       time.August,
		year:        2013,
		expectedDay: 19,
	},
	{
		description: "last Wednesday of September 2013",
		week:        Last,
		weekday:     time.Wednesday,
		month:       time.September,
		year:        2013,
		expectedDay: 25,
	},
}

// weekName maps WeekSchedule constants to their string representations for logging.
var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				panicMsg := fmt.Sprintf("Day(%q, %d, %d, %d) = %d, want: %d",
					weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
				t.Fatalf(panicMsg)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			_ = Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}


=== Test Results (Attempt 7) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup.go:109:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 8 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	var candidates []time.Time

	// Determine the number of days in the month.
	// In Go, the last day of a month can be obtained by using day 0 of the next month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of current month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}

// ----------------------------------------------------------------------
// Note: Although the original file mapping placed this file under .meta, to ensure consistency
// with the test file (which is in package meetup), we use package "meetup" here.

// ----------------------------------------------------------------------

// exercises/practice/meetup/meetup_test.go
package meetup

import (
	"fmt"
	"testing"
	"time"
)

// testCases defines a set of test cases for the Day function.
var testCases = []struct {
	description string
	week        WeekSchedule
	weekday     time.Weekday
	month       time.Month
	year        int
	expectedDay int
}{
	{
		description: "first Monday of January 2013",
		week:        First,
		weekday:     time.Monday,
		month:       time.January,
		year:        2013,
		expectedDay: 7,
	},
	{
		description: "first Tuesday of February 2013",
		week:        First,
		weekday:     time.Tuesday,
		month:       time.February,
		year:        2013,
		expectedDay: 5,
	},
	{
		description: "teenth Monday of August 2013",
		week:        Teenth,
		weekday:     time.Monday,
		month:       time.August,
		expectedDay: 19,
	},
	{
		description: "last Wednesday of September 2013",
		week:        Last,
		weekday:     time.Wednesday,
		month:       time.September,
		year:        2013,
		expectedDay: 25,
	},
}

// weekName maps WeekSchedule constants to their string representations for logging.
var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				panicMsg := fmt.Sprintf("Day(%q, %d, %d, %d) = %d, want: %d",
					weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
				t.Fatalf(panicMsg)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			_ = Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}


=== Test Results (Attempt 8) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup.go:113:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 9 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	var candidates []time.Time

	// Determine the number of days in the month.
	// In Go, the last day of a month can be obtained by using day 0 of the next month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC) // last day of current month
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}

// =====================================================================
// exercises/practice/meetup/meetup_test.go
package meetup

import (
	"fmt"
	"testing"
	"time"
)

// testCases defines a set of test cases for the Day function.
var testCases = []struct {
	description string
	week        WeekSchedule
	weekday     time.Weekday
	month       time.Month
	year        int
	expectedDay int
}{
	{
		description: "first Monday of January 2013",
		week:        First,
		weekday:     time.Monday,
		month:       time.January,
		year:        2013,
		expectedDay: 7,
	},
	{
		description: "first Tuesday of February 2013",
		week:        First,
		weekday:     time.Tuesday,
		month:       time.February,
		year:        2013,
		expectedDay: 5,
	},
	{
		description: "teenth Monday of August 2013",
		week:        Teenth,
		weekday:     time.Monday,
		month:       time.August,
		expectedDay: 19,
	},
	{
		description: "last Wednesday of September 2013",
		week:        Last,
		weekday:     time.Wednesday,
		month:       time.September,
		year:        2013,
		expectedDay: 25,
	},
}

// weekName maps WeekSchedule constants to their string representations for logging.
var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				panicMsg := fmt.Sprintf("Day(%q, %d, %d, %d) = %d, want: %d",
					weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
				t.Fatalf(panicMsg)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			_ = Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}


=== Test Results (Attempt 9) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup.go:106:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 10 ===
// exercises/practice/meetup/.meta/example.go
package meetup

import (
	"fmt"
	"time"
)

// WeekSchedule represents the schedule descriptor for the meetup day.
// It can be values like "teenth", "first", "second", "third", "fourth", "last" etc.
// Predefined constants are provided for convenience.

type WeekSchedule string

const (
	First  WeekSchedule = "first"
	Second WeekSchedule = "second"
	Third  WeekSchedule = "third"
	Fourth WeekSchedule = "fourth"
	Teenth WeekSchedule = "teenth"
	Last   WeekSchedule = "last"
)

// MeetupDayException is the error type raised when the meetup weekday and count do not result in a valid date.
// It implements the error interface, analogous to subclassing ValueError in Python.

type MeetupDayException struct {
	message string
}

func (e *MeetupDayException) Error() string {
	return e.message
}

// Day returns the day of the month for the meetup given the meeting schedule, weekday, month, and year.
// It implements the logic from the provided Python code.
func Day(wSched WeekSchedule, wDay time.Weekday, month time.Month, year int) int {
	// Build list of candidate dates in the given month that match the weekday wDay.
	var candidates []time.Time

	// Determine the number of days in the month.
	// In Go, the last day of a month can be obtained by using day 0 of the next month.
	nextMonth := month + 1
	nextMonthYear := year
	if nextMonth > 12 {
		nextMonth = 1
		nextMonthYear++
	}
	tmp := time.Date(nextMonthYear, nextMonth, 0, 0, 0, 0, 0, time.UTC)
	numDays := tmp.Day()

	for day := 1; day <= numDays; day++ {
		d := time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
		if d.Weekday() == wDay {
			candidates = append(candidates, d)
		}
	}

	// If no candidate exists, panic with the exception
	if len(candidates) == 0 {
		panic(&MeetupDayException{message: "That day does not exist."})
	}

	switch wSched {
	case Teenth:
		for _, d := range candidates {
			if d.Day() >= 13 && d.Day() <= 19 {
				return d.Day()
			}
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	case Last:
		return candidates[len(candidates)-1].Day()
	default:
		// Map ordinal week descriptors to an index (first=0, second=1, third=2, fourth=3)
		ordinal := map[WeekSchedule]int{
			First:  0,
			Second: 1,
			Third:  2,
			Fourth: 3,
		}
		index, ok := ordinal[wSched]
		if !ok {
			panic(fmt.Sprintf("Invalid week descriptor: %s", wSched))
		}
		if index < len(candidates) {
			return candidates[index].Day()
		}
		panic(&MeetupDayException{message: "That day does not exist."})
	}
}

// meetup is provided for compatibility with the Python interface.
// It is a thin wrapper around the Day function. It expects day_of_week as a full weekday name (e.g. "Monday").
// Note: In Go, it's recommended to use the Day function directly with time.Weekday.
func meetup(year int, month time.Month, week WeekSchedule, day_of_week string) int {
	d, err := time.Parse("Monday", day_of_week)
	if err != nil {
		panic(fmt.Sprintf("Invalid day_of_week: %s", day_of_week))
	}
	return Day(week, d.Weekday(), month, year)
}

// ----------------------------------------------------------------------
// End of exercises/practice/meetup/.meta/example.go


// exercises/practice/meetup/meetup_test.go
package meetup

import (
	"fmt"
	"testing"
	"time"
)

// testCases defines a set of test cases for the Day function.
var testCases = []struct {
	description string
	week        WeekSchedule
	weekday     time.Weekday
	month       time.Month
	year        int
	expectedDay int
}{
	{
		description: "first Monday of January 2013",
		week:        First,
		weekday:     time.Monday,
		month:       time.January,
		year:        2013,
		expectedDay: 7,
	},
	{
		description: "first Tuesday of February 2013",
		week:        First,
		weekday:     time.Tuesday,
		month:       time.February,
		year:        2013,
		expectedDay: 5,
	},
	{
		description: "teenth Monday of August 2013",
		week:        Teenth,
		weekday:     time.Monday,
		month:       time.August,
		expectedDay: 19,
	},
	{
		description: "last Wednesday of September 2013",
		week:        Last,
		weekday:     time.Wednesday,
		month:       time.September,
		year:        2013,
		expectedDay: 25,
	},
}

// weekName maps WeekSchedule constants to their string representations for logging.
var weekName = map[WeekSchedule]string{
	First:  "first",
	Second: "second",
	Third:  "third",
	Fourth: "fourth",
	Teenth: "teenth",
	Last:   "last",
}

func TestDay(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			actual := Day(tc.week, tc.weekday, tc.month, tc.year)
			if actual != tc.expectedDay {
				panicMsg := fmt.Sprintf("Day(%q, %d, %d, %d) = %d, want: %d",
					weekName[tc.week], tc.weekday, tc.month, tc.year, actual, tc.expectedDay)
				t.Fatalf(panicMsg)
			}
		})
	}
}

func BenchmarkDay(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			_ = Day(tc.week, tc.weekday, tc.month, tc.year)
		}
	}
}
// ----------------------------------------------------------------------
// End of exercises/practice/meetup/meetup_test.go


=== Test Results (Attempt 10) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/meetup [build failed]
FAIL

=== STDERR ===
# exercism/meetup [exercism/meetup.test]
./meetup.go:109:1: syntax error: non-declaration statement outside function body


=== FINAL STATUS: FAILED ===