=== Initial Source Code ===
Source file: exercises/practice/ledger/.meta/example.py
# -*- coding: utf-8 -*-
from datetime import datetime

ROW_FMT = '{{:<{1}}} | {{:<{2}}} | {{:{0}{3}}}'


def truncate(s, length=25):
    if len(s) <= length:
        return s
    return s[:length - 3] + '...'


class LCInfo:
    def __init__(self, locale, currency, columns):
        self.columns = columns
        if locale == 'en_US':
            headers = ['Date', 'Description', 'Change']
            self.datefmt = '{0.month:02}/{0.day:02}/{0.year:04}'
            self.cur_fmt = '{}{}{}{}'
            self.lead_neg = '('
            self.trail_neg = ')'
            self.thousands = ','
            self.decimal = '.'
        elif locale == 'nl_NL':
            headers = ['Datum', 'Omschrijving', 'Verandering']
            self.datefmt = '{0.day:02}-{0.month:02}-{0.year:04}'
            self.cur_fmt = '{1} {0}{2}{3}'
            self.lead_neg = '-'
            self.trail_neg = ' '
            self.thousands = '.'
            self.decimal = ','
        fmt = ROW_FMT.format('<', *columns)
        self.headers = fmt.format(*headers)
        self.cur_symbol = {
            'USD': '$',
            'EUR': '€',
        }.get(currency)

    def number(self, n):
        n_int, n_float = divmod(abs(n), 100)
        n_int_parts = []
        while n_int > 0:
            n_int, idx = divmod(n_int, 1000)
            n_int_parts.insert(0, str(idx))
        return '{}{}{:02}'.format(
            self.thousands.join(n_int_parts) or '0',
            self.decimal,
            n_float,
        )

    def currency(self, change):
        return self.cur_fmt.format(
            self.lead_neg if change < 0 else '',
            self.cur_symbol,
            self.number(change),
            self.trail_neg if change < 0 else ' ',
        )

    def entry(self, entry):
        date, change, desc = entry
        fmt = ROW_FMT.format('>', *self.columns)
        return fmt.format(
            self.datefmt.format(date),
            truncate(desc),
            self.currency(change),
        )

    def table(self, entries):
        lines = [self.headers]
        lines.extend(map(self.entry, sorted(entries)))
        return '\n'.join(lines)


def create_entry(date, description, change):
    return (
        datetime.strptime(date, '%Y-%m-%d'),
        change,
        description
    )


def format_entries(currency, locale, entries):
    columns = (10, 25, 13)
    lcinfo = LCInfo(locale, currency, columns)
    return lcinfo.table(entries)


=== Source Interface ===
# -*- coding: utf-8 -*-
from datetime import datetime


class LedgerEntry:
    def __init__(self):
        self.date = None
        self.description = None
        self.change = None


def create_entry(date, description, change):
    entry = LedgerEntry()
    entry.date = datetime.strptime(date, '%Y-%m-%d')
    entry.description = description
    entry.change = change
    return entry


def format_entries(currency, locale, entries):
    if locale == 'en_US':
        # Generate Header Row
        table = 'Date'
        for _ in range(7):
            table += ' '
        table += '| Description'
        for _ in range(15):
            table += ' '
        table += '| Change'
        for _ in range(7):
            table += ' '

        while len(entries) > 0:
            table += '\n'

            # Find next entry in order
            min_entry_index = -1
            for i in range(len(entries)):
                entry = entries[i]
                if min_entry_index < 0:
                    min_entry_index = i
                    continue
                min_entry = entries[min_entry_index]
                if entry.date < min_entry.date:
                    min_entry_index = i
                    continue
                if (
                    entry.date == min_entry.date and
                    entry.change < min_entry.change
                ):
                    min_entry_index = i
                    continue
                if (
                    entry.date == min_entry.date and
                    entry.change == min_entry.change and
                    entry.description < min_entry.description
                ):
                    min_entry_index = i
                    continue
            entry = entries[min_entry_index]
            entries.pop(min_entry_index)

            # Write entry date to table
            month = entry.date.month
            month = str(month)
            if len(month) < 2:
                month = '0' + month
            date_str = month
            date_str += '/'
            day = entry.date.day
            day = str(day)
            if len(day) < 2:
                day = '0' + day
            date_str += day
            date_str += '/'
            year = entry.date.year
            year = str(year)
            while len(year) < 4:
                year = '0' + year
            date_str += year
            table += date_str
            table += ' | '

            # Write entry description to table
            # Truncate if necessary
            if len(entry.description) > 25:
                for i in range(22):
                    table += entry.description[i]
                table += '...'
            else:
                for i in range(25):
                    if len(entry.description) > i:
                        table += entry.description[i]
                    else:
                        table += ' '
            table += ' | '

            # Write entry change to table
            if currency == 'USD':
                change_str = ''
                if entry.change < 0:
                    change_str = '('
                change_str += '$'
                change_dollar = abs(int(entry.change / 100.0))
                dollar_parts = []
                while change_dollar > 0:
                    dollar_parts.insert(0, str(change_dollar % 1000))
                    change_dollar = change_dollar // 1000
                if len(dollar_parts) == 0:
                    change_str += '0'
                else:
                    while True:
                        change_str += dollar_parts[0]
                        dollar_parts.pop(0)
                        if len(dollar_parts) == 0:
                            break
                        change_str += ','
                change_str += '.'
                change_cents = abs(entry.change) % 100
                change_cents = str(change_cents)
                if len(change_cents) < 2:
                    change_cents = '0' + change_cents
                change_str += change_cents
                if entry.change < 0:
                    change_str += ')'
                else:
                    change_str += ' '
                while len(change_str) < 13:
                    change_str = ' ' + change_str
                table += change_str
            elif currency == 'EUR':
                change_str = ''
                if entry.change < 0:
                    change_str = '('
                change_str += u'€'
                change_euro = abs(int(entry.change / 100.0))
                euro_parts = []
                while change_euro > 0:
                    euro_parts.insert(0, str(change_euro % 1000))
                    change_euro = change_euro // 1000
                if len(euro_parts) == 0:
                    change_str += '0'
                else:
                    while True:
                        change_str += euro_parts[0]
                        euro_parts.pop(0)
                        if len(euro_parts) == 0:
                            break
                        change_str += ','
                change_str += '.'
                change_cents = abs(entry.change) % 100
                change_cents = str(change_cents)
                if len(change_cents) < 2:
                    change_cents = '0' + change_cents
                change_str += change_cents
                if entry.change < 0:
                    change_str += ')'
                else:
                    change_str += ' '
                while len(change_str) < 13:
                    change_str = ' ' + change_str
                table += change_str
        return table
    elif locale == 'nl_NL':
        # Generate Header Row
        table = 'Datum'
        for _ in range(6):
            table += ' '
        table += '| Omschrijving'
        for _ in range(14):
            table += ' '
        table += '| Verandering'
        for _ in range(2):
            table += ' '

        while len(entries) > 0:
            table += '\n'

            # Find next entry in order
            min_entry_index = -1
            for i in range(len(entries)):
                entry = entries[i]
                if min_entry_index < 0:
                    min_entry_index = i
                    continue
                min_entry = entries[min_entry_index]
                if entry.date < min_entry.date:
                    min_entry_index = i
                    continue
                if (
                    entry.date == min_entry.date and
                    entry.change < min_entry.change
                ):
                    min_entry_index = i
                    continue
                if (
                    entry.date == min_entry.date and
                    entry.change == min_entry.change and
                    entry.description < min_entry.description
                ):
                    min_entry_index = i
                    continue
            entry = entries[min_entry_index]
            entries.pop(min_entry_index)

            # Write entry date to table
            day = entry.date.day
            day = str(day)
            if len(day) < 2:
                day = '0' + day
            date_str = day
            date_str += '-'
            month = entry.date.month
            month = str(month)
            if len(month) < 2:
                month = '0' + month
            date_str += month
            date_str += '-'
            year = entry.date.year
            year = str(year)
            while len(year) < 4:
                year = '0' + year
            date_str += year
            table += date_str
            table += ' | '

            # Write entry description to table
            # Truncate if necessary
            if len(entry.description) > 25:
                for i in range(22):
                    table += entry.description[i]
                table += '...'
            else:
                for i in range(25):
                    if len(entry.description) > i:
                        table += entry.description[i]
                    else:
                        table += ' '
            table += ' | '

            # Write entry change to table
            if currency == 'USD':
                change_str = '$ '
                if entry.change < 0:
                    change_str += '-'
                change_dollar = abs(int(entry.change / 100.0))
                dollar_parts = []
                while change_dollar > 0:
                    dollar_parts.insert(0, str(change_dollar % 1000))
                    change_dollar = change_dollar // 1000
                if len(dollar_parts) == 0:
                    change_str += '0'
                else:
                    while True:
                        change_str += dollar_parts[0]
                        dollar_parts.pop(0)
                        if len(dollar_parts) == 0:
                            break
                        change_str += '.'
                change_str += ','
                change_cents = abs(entry.change) % 100
                change_cents = str(change_cents)
                if len(change_cents) < 2:
                    change_cents = '0' + change_cents
                change_str += change_cents
                change_str += ' '
                while len(change_str) < 13:
                    change_str = ' ' + change_str
                table += change_str
            elif currency == 'EUR':
                change_str = u'€ '
                if entry.change < 0:
                    change_str += '-'
                change_euro = abs(int(entry.change / 100.0))
                euro_parts = []
                while change_euro > 0:
                    euro_parts.insert(0, str(change_euro % 1000))
                    change_euro = change_euro // 1000
                if len(euro_parts) == 0:
                    change_str += '0'
                else:
                    while True:
                        change_str += euro_parts[0]
                        euro_parts.pop(0)
                        if len(euro_parts) == 0:
                            break
                        change_str += '.'
                change_str += ','
                change_cents = abs(entry.change) % 100
                change_cents = str(change_cents)
                if len(change_cents) < 2:
                    change_cents = '0' + change_cents
                change_str += change_cents
                change_str += ' '
                while len(change_str) < 13:
                    change_str = ' ' + change_str
                table += change_str
        return table



=== Target Interface ===
package ledger

import (
	"errors"
	"strconv"
	"strings"
)

type Entry struct {
	Date        string // "Y-m-d"
	Description string
	Change      int // in cents
}

func FormatLedger(currency string, locale string, entries []Entry) (string, error) {
	var entriesCopy []Entry
	for _, e := range entries {
		entriesCopy = append(entriesCopy, e)
	}
	if len(entries) == 0 {
		if _, err := FormatLedger(currency, "en-US", []Entry{{Date: "2014-01-01", Description: "", Change: 0}}); err != nil {
			return "", err
		}
	}
	m1 := map[bool]int{true: 0, false: 1}
	m2 := map[bool]int{true: -1, false: 1}
	es := entriesCopy
	for len(es) > 1 {
		first, rest := es[0], es[1:]
		success := false
		for !success {
			success = true
			for i, e := range rest {
				if (m1[e.Date == first.Date]*m2[e.Date < first.Date]*4 +
					m1[e.Description == first.Description]*m2[e.Description < first.Description]*2 +
					m1[e.Change == first.Change]*m2[e.Change < first.Change]*1) < 0 {
					es[0], es[i+1] = es[i+1], es[0]
					success = false
				}
			}
		}
		es = es[1:]
	}

	var s string
	if locale == "nl-NL" {
		s = "Datum" +
			strings.Repeat(" ", 10-len("Datum")) +
			" | " +
			"Omschrijving" +
			strings.Repeat(" ", 25-len("Omschrijving")) +
			" | " + "Verandering" + "\n"
	} else if locale == "en-US" {
		s = "Date" +
			strings.Repeat(" ", 10-len("Date")) +
			" | " +
			"Description" +
			strings.Repeat(" ", 25-len("Description")) +
			" | " + "Change" + "\n"
	} else {
		return "", errors.New("")
	}
	// Parallelism, always a great idea
	co := make(chan struct {
		i int
		s string
		e error
	})
	for i, et := range entriesCopy {
		go func(i int, entry Entry) {
			if len(entry.Date) != 10 {
				co <- struct {
					i int
					s string
					e error
				}{e: errors.New("")}
			}
			d1, d2, d3, d4, d5 := entry.Date[0:4], entry.Date[4], entry.Date[5:7], entry.Date[7], entry.Date[8:10]
			if d2 != '-' {
				co <- struct {
					i int
					s string
					e error
				}{e: errors.New("")}
			}
			if d4 != '-' {
				co <- struct {
					i int
					s string
					e error
				}{e: errors.New("")}
			}
			de := entry.Description
			if len(de) > 25 {
				de = de[:22] + "..."
			} else {
				de = de + strings.Repeat(" ", 25-len(de))
			}
			var d string
			if locale == "nl-NL" {
				d = d5 + "-" + d3 + "-" + d1
			} else if locale == "en-US" {
				d = d3 + "/" + d5 + "/" + d1
			}
			negative := false
			cents := entry.Change
			if cents < 0 {
				cents = cents * -1
				negative = true
			}
			var a string
			if locale == "nl-NL" {
				if currency == "EUR" {
					a += "€"
				} else if currency == "USD" {
					a += "$"
				} else {
					co <- struct {
						i int
						s string
						e error
					}{e: errors.New("")}
				}
				a += " "
				centsStr := strconv.Itoa(cents)
				switch len(centsStr) {
				case 1:
					centsStr = "00" + centsStr
				case 2:
					centsStr = "0" + centsStr
				}
				rest := centsStr[:len(centsStr)-2]
				var parts []string
				for len(rest) > 3 {
					parts = append(parts, rest[len(rest)-3:])
					rest = rest[:len(rest)-3]
				}
				if len(rest) > 0 {
					parts = append(parts, rest)
				}
				for i := len(parts) - 1; i >= 0; i-- {
					a += parts[i] + "."
				}
				a = a[:len(a)-1]
				a += ","
				a += centsStr[len(centsStr)-2:]
				if negative {
					a += "-"
				} else {
					a += " "
				}
			} else if locale == "en-US" {
				if negative {
					a += "("
				}
				if currency == "EUR" {
					a += "€"
				} else if currency == "USD" {
					a += "$"
				} else {
					co <- struct {
						i int
						s string
						e error
					}{e: errors.New("")}
				}
				centsStr := strconv.Itoa(cents)
				switch len(centsStr) {
				case 1:
					centsStr = "00" + centsStr
				case 2:
					centsStr = "0" + centsStr
				}
				rest := centsStr[:len(centsStr)-2]
				var parts []string
				for len(rest) > 3 {
					parts = append(parts, rest[len(rest)-3:])
					rest = rest[:len(rest)-3]
				}
				if len(rest) > 0 {
					parts = append(parts, rest)
				}
				for i := len(parts) - 1; i >= 0; i-- {
					a += parts[i] + ","
				}
				a = a[:len(a)-1]
				a += "."
				a += centsStr[len(centsStr)-2:]
				if negative {
					a += ")"
				} else {
					a += " "
				}
			} else {
				co <- struct {
					i int
					s string
					e error
				}{e: errors.New("")}
			}
			var al int
			for range a {
				al++
			}
			co <- struct {
				i int
				s string
				e error
			}{i: i, s: d + strings.Repeat(" ", 10-len(d)) + " | " + de + " | " +
				strings.Repeat(" ", 13-al) + a + "\n"}
		}(i, et)
	}
	ss := make([]string, len(entriesCopy))
	for range entriesCopy {
		v := <-co
		if v.e != nil {
			return "", v.e
		}
		ss[v.i] = v.s
	}
	for i := 0; i < len(entriesCopy); i++ {
		s += ss[i]
	}
	return s, nil
}


=== Source Test Code ===
# These tests are auto-generated with test data from:
# https://github.com/exercism/problem-specifications/tree/main/exercises/ledger/canonical-data.json
# File last updated on 2023-12-27

import unittest

from ledger import (
    format_entries,
    create_entry,
)


class LedgerTest(unittest.TestCase):
    maxDiff = 5000

    def test_empty_ledger(self):
        currency = "USD"
        locale = "en_US"
        entries = []
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_one_entry(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Buy present", -1000),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Buy present               |      ($10.00)",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_credit_and_debit(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-02", "Get present", 1000),
            create_entry("2015-01-01", "Buy present", -1000),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Buy present               |      ($10.00)",
                "01/02/2015 | Get present               |       $10.00 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_final_order_tie_breaker_is_change(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Something", 0),
            create_entry("2015-01-01", "Something", -1),
            create_entry("2015-01-01", "Something", 1),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Something                 |       ($0.01)",
                "01/01/2015 | Something                 |        $0.00 ",
                "01/01/2015 | Something                 |        $0.01 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_overlong_description_is_truncated(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Freude schoner Gotterfunken", -123456),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_euros(self):
        currency = "EUR"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Buy present", -1000),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Buy present               |      (€10.00)",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_dutch_locale(self):
        currency = "USD"
        locale = "nl_NL"
        entries = [
            create_entry("2015-03-12", "Buy present", 123456),
        ]
        expected = "\n".join(
            [
                "Datum      | Omschrijving              | Verandering  ",
                "12-03-2015 | Buy present               |   $ 1.234,56 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_dutch_locale_and_euros(self):
        currency = "EUR"
        locale = "nl_NL"
        entries = [
            create_entry("2015-03-12", "Buy present", 123456),
        ]
        expected = "\n".join(
            [
                "Datum      | Omschrijving              | Verandering  ",
                "12-03-2015 | Buy present               |   € 1.234,56 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_dutch_negative_number_with_3_digits_before_decimal_point(self):
        currency = "USD"
        locale = "nl_NL"
        entries = [
            create_entry("2015-03-12", "Buy present", -12345),
        ]
        expected = "\n".join(
            [
                "Datum      | Omschrijving              | Verandering  ",
                "12-03-2015 | Buy present               |    $ -123,45 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_american_negative_number_with_3_digits_before_decimal_point(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-03-12", "Buy present", -12345),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "03/12/2015 | Buy present               |     ($123.45)",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_multiple_entries_on_same_date_ordered_by_description(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Get present", 1000),
            create_entry("2015-01-01", "Buy present", -1000),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Buy present               |      ($10.00)",
                "01/01/2015 | Get present               |       $10.00 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)


=== Target Test Code ===
package ledger

import (
	"reflect"
	"testing"
)

var successTestCases = []struct {
	name     string
	currency string
	locale   string
	entries  []Entry
	expected string
}{
	{
		name:     "empty ledger",
		currency: "USD",
		locale:   "en-US",
		entries:  nil,
		expected: `
Date       | Description               | Change
`,
	},
	{
		name:     "one entry",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Buy present",
				Change:      -1000,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Buy present               |      ($10.00)
`,
	},
	{
		name:     "credit and debit",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-02",
				Description: "Get present",
				Change:      1000,
			},
			{
				Date:        "2015-01-01",
				Description: "Buy present",
				Change:      -1000,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Buy present               |      ($10.00)
01/02/2015 | Get present               |       $10.00 
`,
	},
	{
		name:     "multiple entries on same date ordered by description",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Buy present",
				Change:      -1000,
			},
			{
				Date:        "2015-01-01",
				Description: "Get present",
				Change:      1000,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Buy present               |      ($10.00)
01/01/2015 | Get present               |       $10.00 
`,
	},
	{
		name:     "final order tie breaker is change",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Something",
				Change:      0,
			},
			{
				Date:        "2015-01-01",
				Description: "Something",
				Change:      -1,
			},
			{
				Date:        "2015-01-01",
				Description: "Something",
				Change:      1,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Something                 |       ($0.01)
01/01/2015 | Something                 |        $0.00 
01/01/2015 | Something                 |        $0.01 
`,
	},
	{
		name:     "overlong descriptions",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Freude schoner Gotterfunken",
				Change:      -123456,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
`,
	},
	{
		name:     "euros",
		currency: "EUR",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Buy present",
				Change:      -1000,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Buy present               |      (€10.00)
`,
	},
	{
		name:     "Dutch locale",
		currency: "USD",
		locale:   "nl-NL",
		entries: []Entry{
			{
				Date:        "2015-03-12",
				Description: "Buy present",
				Change:      123456,
			},
		},
		expected: `
Datum      | Omschrijving              | Verandering
12-03-2015 | Buy present               |   $ 1.234,56 
`,
	},
	{
		name:     "Dutch negative number with 3 digits before decimal point",
		currency: "USD",
		locale:   "nl-NL",
		entries: []Entry{
			{
				Date:        "2015-03-12",
				Description: "Buy present",
				Change:      -12345,
			},
		},
		expected: `
Datum      | Omschrijving              | Verandering
12-03-2015 | Buy present               |     $ 123,45-
`,
	},
	{
		name:     "American negative number with 3 digits before decimal point",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-03-12",
				Description: "Buy present",
				Change:      -12345,
			},
		},
		expected: `
Date       | Description               | Change
03/12/2015 | Buy present               |     ($123.45)
`,
	},
}

var failureTestCases = []struct {
	name     string
	currency string
	locale   string
	entries  []Entry
}{
	{
		name:     "empty currency",
		currency: "",
		locale:   "en-US",
		entries:  nil,
	},
	{
		name:     "invalid currency",
		currency: "ABC",
		locale:   "en-US",
		entries:  nil,
	},
	{
		name:     "empty locale",
		currency: "USD",
		locale:   "",
		entries:  nil,
	},
	{
		name:     "invalid locale",
		currency: "USD",
		locale:   "nl-US",
		entries:  nil,
	},
	{
		name:     "invalid date (way too high month)",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-131-11",
				Description: "Buy present",
				Change:      12345,
			},
		},
	},
	{
		name:     "invalid date (wrong separator)",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-12/11",
				Description: "Buy present",
				Change:      12345,
			},
		},
	},
}

func TestFormatLedgerSuccess(t *testing.T) {
	for _, tc := range successTestCases {
		t.Run(tc.name, func(t *testing.T) {
			actual, err := FormatLedger(tc.currency, tc.locale, tc.entries)
			if err != nil {
				t.Fatalf("FormatLedger for input named %q returned unexpected error %v", tc.name, err)
			}
			expected := tc.expected[1:] // Strip initial newline
			if actual != expected {
				t.Fatalf("FormatLedger for input named %q failed\ngot:\n%s\nwant:\n%s", tc.name, actual, expected)
			}
		})
	}
}

func TestFormatLedgerFailure(t *testing.T) {
	for _, tt := range failureTestCases {
		t.Run(tt.name, func(t *testing.T) {
			_, err := FormatLedger(tt.currency, tt.locale, tt.entries)
			if err == nil {
				t.Fatalf("FormatLedger for input %q expected error, got nil", tt.name)
			}
		})
	}
}

func TestFormatLedgerNotChangeInput(t *testing.T) {
	entries := []Entry{
		{
			Date:        "2015-01-02",
			Description: "Freude schöner Götterfunken",
			Change:      1000,
		},
		{
			Date:        "2015-01-01",
			Description: "Buy present",
			Change:      -1000,
		},
	}
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)
	FormatLedger("USD", "en-US", entries)
	if !reflect.DeepEqual(entries, entriesCopy) {
		t.Fatalf("FormatLedger modifies the input entries array")
	}
}

func BenchmarkFormatLedger(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tt := range successTestCases {
			FormatLedger(tt.currency, tt.locale, tt.entries)
		}
	}
}


=== Initial Translation ===
// exercises/practice/ledger/.meta/example.go
package meta

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// ROW_FMT equivalent is not explicitly needed in Go since we use fmt.Sprintf directly
// Default column widths
const (
	dateWidth        = 10
	descriptionWidth = 25
	changeWidth      = 13
)

// truncate truncates a string to a maximum length. If the string is longer than length,
// it returns the string truncated to (length-3) characters with '...' appended.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s
	}
	if length <= 3 {
		return s[:length]
	}
	return s[:length-3] + "..."
}

// LedgerEntry represents an entry with a date, a change in cents, and a description.
// The date is stored as time.Time.
type LedgerEntry struct {
	Date        time.Time
	Change      int
	Description string
}

// LCInfo holds locale and currency formatting information.
// It is used to format ledger entries into a table.
// For en_US:
//   Date format: 01/02/2006
//   Header: "Date       | Description               | Change       "
//   Currency: negative values are wrapped in parentheses, e.g. "($1,234.56)" with right justification to width 13.
// For nl_NL:
//   Date format: 02-01-2006
//   Header: "Datum      | Omschrijving              | Verandering  "
//   Currency: negative values show a leading '-' and trailing ' ', e.g. "€ -1.234,56 " with right justification.
// Note: The column widths are fixed as defined above.

type LCInfo struct {
	Columns   []int
	Headers   string
	DateFmt   string
	LeadNeg   string
	TrailNeg  string
	Thousands string
	Decimal   string
	CurSymbol string
	Locale    string
	Currency  string
}

// NewLCInfo creates a new LCInfo based on the locale and currency provided.
func NewLCInfo(locale, currency string, columns []int) (*LCInfo, error) {
	lc := &LCInfo{
		Columns:  columns,
		Locale:   locale,
		Currency: currency,
	}

	if locale == "en_US" {
		lc.Headers = fmt.Sprintf("%-10s | %-25s | %-13s", "Date", "Description", "Change")
		// Go's time format for MM/DD/YYYY:
		lc.DateFmt = "01/02/2006"
		lc.LeadNeg = "("
		lc.TrailNeg = ")"
		lc.Thousands = ","
		lc.Decimal = "."
	} else if locale == "nl_NL" {
		lc.Headers = fmt.Sprintf("%-10s | %-25s | %-13s", "Datum", "Omschrijving", "Verandering")
		// Go's time format for DD-MM-YYYY:
		lc.DateFmt = "02-01-2006"
		lc.LeadNeg = "-"
		lc.TrailNeg = " "
		lc.Thousands = "."
		lc.Decimal = ","
	} else {
		return nil, errors.New("unsupported locale")
	}

	if currency == "USD" {
		lc.CurSymbol = "$"
	} else if currency == "EUR" {
		lc.CurSymbol = "€"
	} else {
		return nil, errors.New("unsupported currency")
	}

	return lc, nil
}

// Number formats the monetary amount (in cents) into a string with thousands separator and decimal point.
// It does not include the currency symbol or negative sign. For example, 123456 becomes "1,234.56" in en_US.
func (lc *LCInfo) Number(n int) string {
	absVal := n
	if absVal < 0 {
		absVal = -absVal
	}
	intPart := absVal / 100
	cents := absVal % 100

	var parts []string
	if intPart == 0 {
		parts = append(parts, "0")
	} else {
		tmp := intPart
		for tmp > 0 {
			remainder := tmp % 1000
			parts = append([]string{strconv.Itoa(remainder)}, parts...)
			tmp /= 1000
		}
	}

	numberStr := strings.Join(parts, lc.Thousands) + lc.Decimal + fmt.Sprintf("%02d", cents)
	return numberStr
}

// CurrencyFormat formats the change value into a currency string according to LCInfo settings.
// It pads the result to a width of 13 characters by prepending spaces.
func (lc *LCInfo) CurrencyFormat(change int) string {
	negative := change < 0
	formatted := ""

	switch lc.Locale {
	case "en_US":
		if negative {
			formatted += lc.LeadNeg
		}
		formatted += lc.CurSymbol
		formatted += lc.Number(change)
		if negative {
			formatted += lc.TrailNeg
		} else {
			formatted += " "
		}
	case "nl_NL":
		formatted += lc.CurSymbol + " "
		if negative {
			formatted += lc.LeadNeg
		}
		formatted += lc.Number(change)
		if negative {
			formatted += lc.TrailNeg
		} else {
			formatted += " "
		}
	}

	// Right justify to changeWidth (13 characters)
	return fmt.Sprintf("%13s", formatted)
}

// Entry formats a single ledger entry into a string using right-aligned columns for date, description, and change.
func (lc *LCInfo) Entry(e LedgerEntry) string {
	dateStr := e.Date.Format(lc.DateFmt)
	desc := truncate(e.Description, descriptionWidth)
	changeStr := lc.CurrencyFormat(e.Change)
	// For entry rows, fields are right-aligned
	return fmt.Sprintf("%10s | %25s | %13s", dateStr, desc, changeStr)
}

// Table returns the full ledger table as a string. It sorts the entries by date, then change, then description.
func (lc *LCInfo) Table(entries []LedgerEntry) string {
	// Make a copy of entries so as not to mutate the input
	sortedEntries := make([]LedgerEntry, len(entries))
	copy(sortedEntries, entries)

	sort.Slice(sortedEntries, func(i, j int) bool {
		if sortedEntries[i].Date.Equal(sortedEntries[j].Date) {
			if sortedEntries[i].Change == sortedEntries[j].Change {
				return sortedEntries[i].Description < sortedEntries[j].Description
			}
			return sortedEntries[i].Change < sortedEntries[j].Change
		}
		return sortedEntries[i].Date.Before(sortedEntries[j].Date)
	})

	lines := []string{lc.Headers}
	for _, e := range sortedEntries {
		lines = append(lines, lc.Entry(e))
	}

	return strings.Join(lines, "\n")
}

// CreateEntry parses the given date string (in "2006-01-02" format), and creates a new LedgerEntry
// with the provided description and change (in cents).
func CreateEntry(dateStr, description string, change int) (LedgerEntry, error) {
	t, err := time.Parse("2006-01-02", dateStr)
	if err != nil {
		return LedgerEntry{}, err
	}
	return LedgerEntry{
		Date:        t,
		Change:      change,
		Description: description,
	}, nil
}

// FormatEntries formats a list of ledger entries into a formatted table string.
// It takes the currency ("USD" or "EUR"), the locale ("en_US" or "nl_NL"),
// and the entries to format.
func FormatEntries(currency, locale string, entries []LedgerEntry) (string, error) {
	columns := []int{dateWidth, descriptionWidth, changeWidth}
	lc, err := NewLCInfo(locale, currency, columns)
	if err != nil {
		return "", err
	}
	return lc.Table(entries), nil
}


=== Initial Test Results ===
Return code: 1
=== STDOUT ===

=== STDERR ===
found packages meta (ledger.go) and ledger (ledger_test.go) in /private/var/folders/gy/0zbg6hg95tq8_gy1dnr3tknm0000gn/T/tmpt_h86ptc/sandbox/exercises/practice/ledger


=== Retry Attempt 1 ===
// exercises/practice/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeaderDate        = "Date"
	enHeaderDescription = "Description"
	enHeaderChange      = "Change"

	dutchHeaderDate        = "Datum"
	dutchHeaderDescription = "Omschrijving"
	dutchHeaderChange      = "Verandering"

	enDateLayout  = "01/02/2006"  // mm/dd/yyyy
	dutchDateLayout = "02-01-2006" // dd-mm-yyyy

	columnDate        = 10
	columnDescription = 25
	columnChange      = 13
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	// Validate currency and locale
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Make a copy of the entries so as not to modify the input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Sort the entries
	// Sorting criteria: by date ascending, then description ascending, then change ascending
	for i := range entriesCopy {
		// Validate date format and parse
		if len(entriesCopy[i].Date) != 10 {
			return "", errors.New("")
		}
		// basic check for '-' at positions 4 and 7
		if entriesCopy[i].Date[4] != '-' || entriesCopy[i].Date[7] != '-' {
			return "", errors.New("")
		}
	}

	err := sortEntries(entriesCopy)
	if err != nil {
		return "", err
	}

	// Build header
	var header string
	if locale == "en-US" {
		header = fmt.Sprintf("%-10s | %-25s | %-13s", enHeaderDate, enHeaderDescription, enHeaderChange)
	} else { // nl-NL
		header = fmt.Sprintf("%-10s | %-25s | %-13s", dutchHeaderDate, dutchHeaderDescription, dutchHeaderChange)
	}

	// Build table lines
	lines := []string{header}

	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts the entries in place with the following criteria:
// date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	return sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			// if parsing fails, treat as equal (and error will be caught earlier)
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse the date from YYYY-MM-DD
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(dutchDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, columnDescription)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Format row: date (left, width 10), description (left, width 25), change (right, width 13)
	row := fmt.Sprintf("%-10s | %-25s | %13s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to length if necessary, adding "..." if truncated.
// The total length will be exactly len if s exceeds it, with last 3 chars '...'.
func truncate(s string, length int) string {
	if len(s) <= length {
		// pad with spaces to fill length
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value as a currency string according to locale rules.
// It returns a string right justified to 13 characters.
func formatChange(change int, currency, locale string) (string, error) {
	var symbol string
	if currency == "USD" {
		symbol = "$"
	} else if currency == "EUR" {
		symbol = "€"
	} else {
		return "", errors.New("")
	}

	absVal := change
	negative := false
	if change < 0 {
		absVal = -change
		negative = true
	}

	dollars := absVal / 100
	cents := absVal % 100

	var dollarStr string
	if locale == "en-US" {
		dollarStr = insertThousandSeparator(dollars, ",")
	} else if locale == "nl-NL" {
		dollarStr = insertThousandSeparator(dollars, ".")
	} else {
		return "", errors.New("")
	}

	amount := fmt.Sprintf("%s%s%02d", dollarStr, (func() string {
		if locale == "en-US" {
			return "."
		}
		return ","
	})(), cents)

	var formatted string
	if locale == "en-US" {
		if negative {
			formatted = fmt.Sprintf("(%s%s%s)", symbol, amount, "")
		} else {
			formatted = fmt.Sprintf("%s%s%s", symbol, amount, " ")
		}
	} else if locale == "nl-NL" {
		// In Dutch locale, the format is: symbol + space + amount and then a trailing sign
		if negative {
			formatted = fmt.Sprintf("%s %s-", symbol, amount)
		} else {
			formatted = fmt.Sprintf("%s %s ", symbol, amount)
		}
	}

	// Right justify to width 13
	return fmt.Sprintf("%13s", formatted), nil
}

// insertThousandSeparator formats an integer with a separator. For example, 1234 with sep="," becomes "1,234".
func insertThousandSeparator(n int, sep string) string {
	nStr := strconv.Itoa(n)
	if n < 1000 {
		return nStr
	}
	var parts []string
	for len(nStr) > 3 {
		parts = append([]string{nStr[len(nStr)-3:]}, parts...)
		nStr = nStr[:len(nStr)-3]
	}
	parts = append([]string{nStr}, parts...)
	return strings.Join(parts, sep)
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry.
func CreateEntry(date, description string, change int) (Entry, error) {
	// Validate and parse the date
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 1) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/ledger [build failed]
FAIL

=== STDERR ===
# exercism/ledger [exercism/ledger.test]
./ledger.go:100:9: sort.SliceStable(entries, func(i, j int) bool {…}) (no value) used as value


=== Retry Attempt 2 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeaderDate        = "Date"
	enHeaderDescription = "Description"
	enHeaderChange      = "Change"

	dutchHeaderDate        = "Datum"
	dutchHeaderDescription = "Omschrijving"
	dutchHeaderChange      = "Verandering"

	enDateLayout   = "01/02/2006"  // MM/DD/YYYY
	dutchDateLayout = "02-01-2006" // DD-MM-YYYY

	columnDate        = 10
	columnDescription = 25
	columnChange      = 13
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	// Validate currency and locale
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Make a copy of the entries to avoid mutating the input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	// Sort the entries
	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	// Build header
	var header string
	if locale == "en-US" {
		header = fmt.Sprintf("%-10s | %-25s | %-13s", enHeaderDate, enHeaderDescription, enHeaderChange)
	} else { // nl-NL
		header = fmt.Sprintf("%-10s | %-25s | %-13s", dutchHeaderDate, dutchHeaderDescription, dutchHeaderChange)
	}

	// Build table lines
	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts the entries in place using the following criteria:
// date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse the date from YYYY-MM-DD
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(dutchDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, columnDescription)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Format row: date (left, width 10), description (left, width 25), change (right, width 13)
	row := fmt.Sprintf("%-10s | %-25s | %13s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it is truncated to length-3 and '...' is appended.
// If s is shorter, it is padded with spaces to reach the exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value as a currency string according to locale rules.
// It returns a string right-justified to columnChange characters.
func formatChange(change int, currency, locale string) (string, error) {
	var symbol string
	if currency == "USD" {
		symbol = "$"
	} else if currency == "EUR" {
		symbol = "€"
	} else {
		return "", errors.New("")
	}

	absVal := change
	negative := false
	if change < 0 {
		absVal = -change
		negative = true
	}

	dollars := absVal / 100
	cents := absVal % 100

	var dollarStr string
	if locale == "en-US" {
		dollarStr = insertThousandSeparator(dollars, ",")
	} else if locale == "nl-NL" {
		dollarStr = insertThousandSeparator(dollars, ".")
	} else {
		return "", errors.New("")
	}

	var sep string
	if locale == "en-US" {
		sep = "."
	} else {
		sep = ","
	}

	amount := fmt.Sprintf("%s%s%02d", dollarStr, sep, cents)

	var formatted string
	if locale == "en-US" {
		if negative {
			formatted = fmt.Sprintf("(%s%s)", symbol, amount)
		} else {
			formatted = fmt.Sprintf("%s%s ", symbol, amount)
		}
	} else if locale == "nl-NL" {
		if negative {
			formatted = fmt.Sprintf("%s %s-", symbol, amount)
		} else {
			formatted = fmt.Sprintf("%s %s ", symbol, amount)
		}
	} else {
		return "", errors.New("")
	}

	// Right justify to columnChange width
	return fmt.Sprintf("%13s", formatted), nil
}

// insertThousandSeparator formats an integer n with a separator.
// For example, 1234 with sep="," becomes "1,234".
func insertThousandSeparator(n int, sep string) string {
	nStr := strconv.Itoa(n)
	if n < 1000 {
		return nStr
	}
	var parts []string
	for len(nStr) > 3 {
		parts = append([]string{nStr[len(nStr)-3:]}, parts...)
		nStr = nStr[:len(nStr)-3]
	}
	parts = append([]string{nStr}, parts...)
	return strings.Join(parts, sep)
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 2) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
            Date       | Description               | Change       
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
            Date       | Description               | Change       
            01/01/2015 | Buy present               |      ($10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
            Date       | Description               | Change       
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
            Date       | Description               | Change       
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
            Date       | Description               | Change       
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
            Date       | Description               | Change       
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
            Date       | Description               | Change       
            01/01/2015 | Buy present               |      (€10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
            Datum      | Omschrijving              | Verandering  
            12-03-2015 | Buy present               |   $ 1.234,56 
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
            Datum      | Omschrijving              | Verandering  
            12-03-2015 | Buy present               |     $ 123,45-
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
            Date       | Description               | Change       
            03/12/2015 | Buy present               |     ($123.45)
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.502s
FAIL

=== STDERR ===


=== Retry Attempt 3 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeaderDate        = "Date"
	enHeaderDescription = "Description"
	enHeaderChange      = "Change"

	dutchHeaderDate        = "Datum"
	dutchHeaderDescription = "Omschrijving"
	dutchHeaderChange      = "Verandering"

	enDateLayout    = "01/02/2006"  // MM/DD/YYYY
	dutchDateLayout  = "02-01-2006" // DD-MM-YYYY

	columnDate        = 10
	columnDescription = 25
	columnChange      = 14
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Make a copy of entries to avoid modifying input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	// Sort the entries
	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	// Build header (no extra padding)
	var header string
	if locale == "en-US" {
		header = "Date       | Description               | Change"
	} else { // nl-NL
		header = "Datum      | Omschrijving              | Verandering"
	}

	// Build table lines
	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts entries in place using date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse date
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(dutchDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, columnDescription)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Row: date left-justified 10, description left-justified 25, change right-justified 14
	row := fmt.Sprintf("%-10s | %-25s | %14s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it truncates to length-3 and appends "...".
// If s is shorter, it pads it with spaces to reach exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value as a currency string according to locale rules.
// Returns a string right-justified to columnChange characters.
func formatChange(change int, currency, locale string) (string, error) {
	var symbol string
	if currency == "USD" {
		symbol = "$"
	} else if currency == "EUR" {
		symbol = "€"
	} else {
		return "", errors.New("")
	}

	absVal := change
	negative := false
	if change < 0 {
		absVal = -change
		negative = true
	}

	dollars := absVal / 100
	cents := absVal % 100

	var dollarStr string
	if locale == "en-US" {
		dollarStr = insertThousandSeparator(dollars, ",")
	} else if locale == "nl-NL" {
		dollarStr = insertThousandSeparator(dollars, ".")
	} else {
		return "", errors.New("")
	}

	var sep string
	if locale == "en-US" {
		sep = "."
	} else {
		sep = ","
	}

	amount := fmt.Sprintf("%s%s%02d", dollarStr, sep, cents)

	var formatted string
	if locale == "en-US" {
		if negative {
			formatted = fmt.Sprintf("(%s%s)", symbol, amount)
		} else {
			formatted = fmt.Sprintf("%s%s ", symbol, amount)
		}
	} else if locale == "nl-NL" {
		if negative {
			formatted = fmt.Sprintf("%s %s-", symbol, amount)
		} else {
			formatted = fmt.Sprintf("%s %s ", symbol, amount)
		}
	} else {
		return "", errors.New("")
	}

	// Right justify to columnChange width
	return fmt.Sprintf("%14s", formatted), nil
}

// insertThousandSeparator formats an integer n with a separator.
// For example, 1234 with sep="," becomes "1,234".
func insertThousandSeparator(n int, sep string) string {
	nStr := strconv.Itoa(n)
	if n < 1000 {
		return nStr
	}
	var parts []string
	for len(nStr) > 3 {
		parts = append([]string{nStr[len(nStr)-3:]}, parts...)
		nStr = nStr[:len(nStr)-3]
	}
	parts = append([]string{nStr}, parts...)
	return strings.Join(parts, sep)
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 3) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
            Date       | Description               | Change
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/02/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/01/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Something                 |        ($0.01)
            01/01/2015 | Something                 |         $0.00 
            01/01/2015 | Something                 |         $0.01 
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |    ($1,234.56)
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       (€10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |    $ 1.234,56 
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |      $ 123,45-
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
            Date       | Description               | Change
            03/12/2015 | Buy present               |      ($123.45)
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.274s
FAIL

=== STDERR ===


=== Retry Attempt 4 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeaderDate        = "Date       | Description               | Change"
	dutchHeaderDate     = "Datum      | Omschrijving              | Verandering"

	enDateLayout    = "01/02/2006"  // MM/DD/YYYY
	dutchDateLayout  = "02-01-2006" // DD-MM-YYYY

	columnDate        = 10
	columnDescription = 25
	columnChange      = 14
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Make a copy of entries to avoid modifying input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	// Sort the entries
	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	// Build header
	var header string
	if locale == "en-US" {
		header = enHeaderDate
	} else { // nl-NL
		header = dutchHeaderDate
	}

	// Build table lines
	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts entries in place using date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse date
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(dutchDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, columnDescription)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Row: date left-justified 10, description left-justified 25, change right-justified 14
	row := fmt.Sprintf("%-10s | %-25s | %14s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it truncates to length-3 and appends "...".
// If s is shorter, it pads it with spaces to reach exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value as a currency string according to locale rules.
// Returns an unpadded string; the caller will pad it to a width of 14 characters.
func formatChange(change int, currency, locale string) (string, error) {
	var symbol string
	if currency == "USD" {
		symbol = "$"
	} else if currency == "EUR" {
		symbol = "€"
	} else {
		return "", errors.New("")
	}

	absVal := change
	negative := false
	if change < 0 {
		absVal = -change
		negative = true
	}

	dollars := absVal / 100
	cents := absVal % 100

	var dollarStr string
	if locale == "en-US" {
		dollarStr = insertThousandSeparator(dollars, ",")
	} else if locale == "nl-NL" {
		dollarStr = insertThousandSeparator(dollars, ".")
	} else {
		return "", errors.New("")
	}

	var sep string
	if locale == "en-US" {
		sep = "."
	} else {
		sep = ","
	}

	amount := fmt.Sprintf("%s%s%02d", dollarStr, sep, cents)

	var formatted string
	if locale == "en-US" {
		if negative {
			formatted = fmt.Sprintf("(%s%s)", symbol, amount)
		} else {
			formatted = fmt.Sprintf("%s%s ", symbol, amount)
		}
	} else if locale == "nl-NL" {
		if negative {
			formatted = fmt.Sprintf("%s %s-", symbol, amount)
		} else {
			formatted = fmt.Sprintf("%s %s ", symbol, amount)
		}
	} else {
		return "", errors.New("")
	}

	return formatted, nil
}

// insertThousandSeparator formats an integer n with a separator.
// For example, 1234 with sep="," becomes "1,234".
func insertThousandSeparator(n int, sep string) string {
	nStr := strconv.Itoa(n)
	if n < 1000 {
		return nStr
	}
	var parts []string
	for len(nStr) > 3 {
		parts = append([]string{nStr[len(nStr)-3:]}, parts...)
		nStr = nStr[:len(nStr)-3]
	}
	parts = append([]string{nStr}, parts...)
	return strings.Join(parts, sep)
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 4) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
            Date       | Description               | Change
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/02/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/01/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Something                 |        ($0.01)
            01/01/2015 | Something                 |         $0.00 
            01/01/2015 | Something                 |         $0.01 
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |    ($1,234.56)
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       (€10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |    $ 1.234,56 
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |      $ 123,45-
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
            Date       | Description               | Change
            03/12/2015 | Buy present               |      ($123.45)
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.285s
FAIL

=== STDERR ===


=== Retry Attempt 5 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeader = "Date       | Description               | Change"
	nlHeader  = "Datum      | Omschrijving              | Verandering"

	enDateLayout   = "01/02/2006"  // MM/DD/YYYY
	nlDateLayout   = "02-01-2006" // DD-MM-YYYY

	dateWidth        = 10
	descWidth        = 25
	// The change column is formatted by our custom functions, always padded to 13 characters.
	changeWidth      = 13
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Copy entries to avoid modification
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	var header string
	if locale == "en-US" {
		header = enHeader
	} else {
		header = nlHeader
	}

	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts entries in place using date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse date
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(nlDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, descWidth)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Build row: date left-justified (10), description left-justified (25), then change (already padded to 13 by formatChange)
	row := fmt.Sprintf("%-10s | %-25s | %s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it truncates to length-3 and appends "...".
// If s is shorter, it pads it with spaces to reach the exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value according to locale and currency rules.
// It returns a string padded on the left to exactly 13 characters.
func formatChange(change int, currency, locale string) (string, error) {
	if locale == "en-US" {
		return formatChangeUS(change, currency)
	} else if locale == "nl-NL" {
		return formatChangeNL(change, currency)
	}
	return "", errors.New("")
}

// formatChangeUS implements the en-US formatting for monetary change.
func formatChangeUS(change int, currency string) (string, error) {
	var s string
	if change < 0 {
		s = "("
	} else {
		s = ""
	}

	if currency == "USD" {
		s += "$"
	} else if currency == "EUR" {
		s += "€"
	} else {
		return "", errors.New("")
	}

	absChange := change
	if change < 0 {
		absChange = -change
	}

	dollar := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollar, ",")
	s += dollarStr
	s += "."
	s += fmt.Sprintf("%02d", cents)

	if change < 0 {
		s += ")"
	} else {
		s += " "
	}

	// Pad s on the left until its length is 13
	for len(s) < 13 {
		s = " " + s
	}

	return s, nil
}

// formatChangeNL implements the nl-NL formatting for monetary change.
func formatChangeNL(change int, currency string) (string, error) {
	var s string
	if currency == "USD" {
		s = "$ "
	} else if currency == "EUR" {
		s = "€ "
	} else {
		return "", errors.New("")
	}

	if change < 0 {
		s += "-"
	}

	absChange := change
	if change < 0 {
		absChange = -change
	}

	dollar := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollar, ".")
	s += dollarStr
	s += ","
	s += fmt.Sprintf("%02d", cents)

	if change >= 0 {
		s += " "
	}

	// Pad s on the left until its length is 13
	for len(s) < 13 {
		s = " " + s
	}

	return s, nil
}

// formatThousand formats an integer with a thousands separator.
func formatThousand(n int, sep string) string {
	if n == 0 {
		return "0"
	}
	var parts []string
	for n > 0 {
		d := n % 1000
		n = n / 1000
		// For the most significant group, don't pad; for others, pad to 3 digits
		if len(parts) > 0 {
			parts = append([]string{fmt.Sprintf("%03d", d)}, parts...)
		} else {
			parts = append([]string{strconv.Itoa(d)}, parts...)
		}
	}
	return strings.Join(parts, sep)
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 5) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
            Date       | Description               | Change
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... | ($001,234.56)
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |    (€10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               | $ 001.234,56 
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ -123,45
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.303s
FAIL

=== STDERR ===


=== Retry Attempt 6 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeader = "Date       | Description               | Change"
	nlHeader  = "Datum      | Omschrijving              | Verandering"

	enDateLayout = "01/02/2006"  // MM/DD/YYYY
	nlDateLayout = "02-01-2006" // DD-MM-YYYY

	dateWidth = 10
	descWidth = 25
	// The change field should be formatted to a width of 14 characters
	changeWidth = 14
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Copy entries to avoid modifying input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	var header string
	if locale == "en-US" {
		header = enHeader
	} else {
		header = nlHeader
	}

	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts entries in place using date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse date
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(nlDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, descWidth)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Build row: date left-justified (10), description left-justified (25), change (already padded to 14)
	row := fmt.Sprintf("%-10s | %-25s | %s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it truncates to (length - 3) and appends "...".
// If s is shorter, it pads it with spaces to reach the exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value according to locale and currency rules, then pads it to width 14.
func formatChange(change int, currency, locale string) (string, error) {
	var unpadded string
	var err error
	if locale == "en-US" {
		unpadded, err = formatChangeUS(change, currency)
	} else if locale == "nl-NL" {
		unpadded, err = formatChangeNL(change, currency)
	} else {
		return "", errors.New("")
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%14s", unpadded), nil
}

// currencySymbol returns the symbol for a given currency.
func currencySymbol(currency string) string {
	if currency == "USD" {
		return "$"
	} else if currency == "EUR" {
		return "€"
	}
	return ""
}

// formatChangeUS implements the en-US formatting for monetary change.
func formatChangeUS(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ",")
	amount := fmt.Sprintf("%s.%02d", dollarStr, cents)

	var formatted string
	if negative {
		formatted = fmt.Sprintf("(%s%s)", currencySymbol(currency), amount)
	} else {
		formatted = fmt.Sprintf("%s%s ", currencySymbol(currency), amount)
	}

	return formatted, nil
}

// formatChangeNL implements the nl-NL formatting for monetary change.
func formatChangeNL(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ".")
	amount := fmt.Sprintf("%s,%02d", dollarStr, cents)

	var suffix string
	if negative {
		suffix = "-"
	} else {
		suffix = " "
	}

	formatted := fmt.Sprintf("%s %s%s", currencySymbol(currency), amount, suffix)

	return formatted, nil
}

// formatThousand formats an integer with a thousands separator.
func formatThousand(n int, sep string) string {
	if n == 0 {
		return "0"
	}
	var parts []string
	for n > 0 {
		d := n % 1000
		n = n / 1000
		if len(parts) > 0 {
			parts = append([]string{fmt.Sprintf("%03d", d)}, parts...)
		} else {
			parts = append([]string{strconv.Itoa(d)}, parts...)
		}
	}
	return strings.Join(parts, sep)
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 6) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
            Date       | Description               | Change
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/02/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/01/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Something                 |        ($0.01)
            01/01/2015 | Something                 |         $0.00 
            01/01/2015 | Something                 |         $0.01 
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |  ($001,234.56)
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       (€10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |  $ 001.234,56 
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |      $ 123,45-
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
            Date       | Description               | Change
            03/12/2015 | Buy present               |      ($123.45)
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.277s
FAIL

=== STDERR ===


=== Retry Attempt 7 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeader = "Date       | Description               | Change"
	nlHeader  = "Datum      | Omschrijving              | Verandering"

	enDateLayout = "01/02/2006"  // MM/DD/YYYY
	nlDateLayout = "02-01-2006" // DD-MM-YYYY

	dateWidth = 10
	descWidth = 25
	// The change field in row should occupy 14 characters
	changeFieldWidth = 14
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Copy entries to avoid modifying input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	var header string
	if locale == "en-US" {
		header = enHeader
	} else {
		header = nlHeader
	}

	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts entries in place using date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse date
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(nlDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, descWidth)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Build row: date left-justified (10), description left-justified (25), then change field (already padded to changeFieldWidth)
	row := fmt.Sprintf("%-10s | %-25s | %s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it truncates to (length - 3) and appends "...".
// If s is shorter, it pads it with spaces to reach the exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value according to locale and currency rules, then pads it to changeFieldWidth characters.
func formatChange(change int, currency, locale string) (string, error) {
	var unpadded string
	var err error
	if locale == "en-US" {
		unpadded, err = formatChangeUS(change, currency)
	} else if locale == "nl-NL" {
		unpadded, err = formatChangeNL(change, currency)
	} else {
		return "", errors.New("")
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%14s", unpadded), nil
}

// formatChangeUS implements the en-US formatting for monetary change.
func formatChangeUS(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ",")
	amount := fmt.Sprintf("%s.%02d", dollarStr, cents)

	var formatted string
	if negative {
		// Ensure the unpadded negative string is 8 characters by including the currency symbol
		formatted = fmt.Sprintf("(%s%s)", getSymbol(currency), amount)
	} else {
		formatted = fmt.Sprintf("%s%s ", getSymbol(currency), amount)
	}

	return formatted, nil
}

// formatChangeNL implements the nl-NL formatting for monetary change.
func formatChangeNL(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ".")
	amount := fmt.Sprintf("%s,%02d", dollarStr, cents)

	var suffix string
	if negative {
		suffix = "-"
	} else {
		suffix = " "
	}

	formatted := fmt.Sprintf("%s %s%s", getSymbol(currency), amount, suffix)

	return formatted, nil
}

// getSymbol returns the currency symbol for the given currency.
func getSymbol(currency string) string {
	if currency == "USD" {
		return "$"
	} else if currency == "EUR" {
		return "€"
	}
	return ""
}

// formatThousand formats an integer with a thousands separator.
func formatThousand(n int, sep string) string {
	if n == 0 {
		return "0"
	}
	var parts []string
	for n > 0 {
		d := n % 1000
		n = n / 1000
		if len(parts) > 0 {
			parts = append([]string{fmt.Sprintf("%03d", d)}, parts...)
		} else {
			parts = append([]string{strconv.Itoa(d)}, parts...)
		}
	}
	return strings.Join(parts, sep)
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 7) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
            Date       | Description               | Change
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/02/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/01/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Something                 |        ($0.01)
            01/01/2015 | Something                 |         $0.00 
            01/01/2015 | Something                 |         $0.01 
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |  ($001,234.56)
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       (€10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |  $ 001.234,56 
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |      $ 123,45-
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
            Date       | Description               | Change
            03/12/2015 | Buy present               |      ($123.45)
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.279s
FAIL

=== STDERR ===


=== Retry Attempt 8 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeader = "Date       | Description               | Change"
	nlHeader  = "Datum      | Omschrijving              | Verandering"

	enDateLayout = "01/02/2006"  // MM/DD/YYYY
	nlDateLayout = "02-01-2006" // DD-MM-YYYY

	dateWidth        = 10
	descWidth        = 25
	changeFieldWidth = 14 // as determined to match expected output
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Copy entries so as not to modify the input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	var header string
	if locale == "en-US" {
		header = enHeader
	} else {
		header = nlHeader
	}

	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts entries in place using date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse date
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(nlDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, descWidth)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Build row: date left-justified (10), description left-justified (25), change field (padded to 14)
	row := fmt.Sprintf("%-10s | %-25s | %s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it truncates to (length - 3) and appends "...".
// If s is shorter, it pads it with spaces to reach the exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value according to locale and currency rules, then pads it to changeFieldWidth characters.
func formatChange(change int, currency, locale string) (string, error) {
	var unpadded string
	var err error
	if locale == "en-US" {
		unpadded, err = formatChangeUS(change, currency)
	} else if locale == "nl-NL" {
		unpadded, err = formatChangeNL(change, currency)
	} else {
		return "", errors.New("")
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%14s", unpadded), nil
}

// formatChangeUS implements the en-US formatting for monetary change.
func formatChangeUS(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ",")
	amount := fmt.Sprintf("%s.%02d", dollarStr, cents)

	var formatted string
	if negative {
		formatted = fmt.Sprintf("(%s%s)", getSymbol(currency), amount)
	} else {
		formatted = fmt.Sprintf("%s%s ", getSymbol(currency), amount)
	}

	return formatted, nil
}

// formatChangeNL implements the nl-NL formatting for monetary change.
func formatChangeNL(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ".")
	amount := fmt.Sprintf("%s,%02d", dollarStr, cents)

	var suffix string
	if negative {
		suffix = "-"
	} else {
		suffix = " "
	}

	formatted := fmt.Sprintf("%s %s%s", getSymbol(currency), amount, suffix)

	return formatted, nil
}

// getSymbol returns the currency symbol for the given currency.
func getSymbol(currency string) string {
	if currency == "USD" {
		return "$"
	} else if currency == "EUR" {
		return "€"
	}
	return ""
}

// formatThousand formats an integer with a thousands separator.
func formatThousand(n int, sep string) string {
	if n == 0 {
		return "0"
	}
	var parts []string
	for n > 0 {
		d := n % 1000
		n = n / 1000
		if len(parts) > 0 {
			parts = append([]string{fmt.Sprintf("%03d", d)}, parts...)
		} else {
			parts = append([]string{strconv.Itoa(d)}, parts...)
		}
	}
	return strings.Join(parts, sep)
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 8) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
            Date       | Description               | Change
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/02/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       ($10.00)
            01/01/2015 | Get present               |        $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Something                 |        ($0.01)
            01/01/2015 | Something                 |         $0.00 
            01/01/2015 | Something                 |         $0.01 
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |  ($001,234.56)
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |       (€10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |  $ 001.234,56 
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |      $ 123,45-
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
            Date       | Description               | Change
            03/12/2015 | Buy present               |      ($123.45)
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.279s
FAIL

=== STDERR ===


=== Retry Attempt 9 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeader = "Date       | Description               | Change"
	nlHeader  = "Datum      | Omschrijving              | Verandering"

	enDateLayout = "01/02/2006"  // MM/DD/YYYY
	nlDateLayout = "02-01-2006" // DD-MM-YYYY

	dateWidth        = 10
	descWidth        = 25
	changeFieldWidth = 13
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Copy entries so as not to modify the input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	var header string
	if locale == "en-US" {
		header = enHeader
	} else {
		header = nlHeader
	}

	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts entries in place using date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse date
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(nlDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, descWidth)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Build row: date left-justified (10), description left-justified (25), change field (padded to changeFieldWidth)
	row := fmt.Sprintf("%-10s | %-25s | %s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it truncates to (length - 3) and appends "...".
// If s is shorter, it pads it with spaces to reach the exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value according to locale and currency rules, then pads it to changeFieldWidth characters.
func formatChange(change int, currency, locale string) (string, error) {
	var unpadded string
	var err error
	if locale == "en-US" {
		unpadded, err = formatChangeUS(change, currency)
	} else if locale == "nl-NL" {
		unpadded, err = formatChangeNL(change, currency)
	} else {
		return "", errors.New("")
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%13s", unpadded), nil
}

// formatChangeUS implements the en-US formatting for monetary change.
func formatChangeUS(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ",")
	amount := fmt.Sprintf("%s.%02d", dollarStr, cents)

	var formatted string
	if negative {
		formatted = fmt.Sprintf("(%s%s)", getSymbol(currency), amount)
	} else {
		formatted = fmt.Sprintf("%s%s ", getSymbol(currency), amount)
	}

	return formatted, nil
}

// formatChangeNL implements the nl-NL formatting for monetary change.
func formatChangeNL(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ".")
	amount := fmt.Sprintf("%s,%02d", dollarStr, cents)

	var suffix string
	if negative {
		suffix = "-"
	} else {
		suffix = " "
	}

	formatted := fmt.Sprintf("%s %s%s", getSymbol(currency), amount, suffix)

	return formatted, nil
}

// getSymbol returns the currency symbol for the given currency.
func getSymbol(currency string) string {
	if currency == "USD" {
		return "$"
	} else if currency == "EUR" {
		return "€"
	}
	return ""
}

// formatThousand formats an integer with a thousands separator.
// It does not pad the most significant group.
func formatThousand(n int, sep string) string {
	s := strconv.Itoa(n)
	if len(s) <= 3 {
		return s
	}
	mod := len(s) % 3
	var result string
	if mod != 0 {
		result = s[:mod]
	} else {
		result = s[:3]
		mod = 3
	}
	for i := mod; i < len(s); i += 3 {
		result += sep + s[i:i+3]
	}
	return result
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 9) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
            Date       | Description               | Change
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.288s
FAIL

=== STDERR ===


=== Retry Attempt 10 ===
// exercism/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// Entry represents a ledger entry with a date, description, and change (in cents).
// The date is a string in the format "YYYY-MM-DD".
// It is the interface required by the tests.

type Entry struct {
	Date        string
	Description string
	Change      int
}

const (
	enHeader = "Date       | Description               | Change"
	nlHeader  = "Datum      | Omschrijving              | Verandering"

	enDateLayout = "01/02/2006"  // MM/DD/YYYY
	nlDateLayout = "02-01-2006" // DD-MM-YYYY

	dateWidth        = 10
	descWidth        = 25
	changeFieldWidth = 14
)

// FormatLedger formats a list of ledger entries into a table string.
// It takes the currency ("USD" or "EUR"), the locale ("en-US" or "nl-NL"), and the entries to format.
// Returns the table string and an error if any occurs.
func FormatLedger(currency, locale string, entries []Entry) (string, error) {
	if currency != "USD" && currency != "EUR" {
		return "", errors.New("")
	}
	if locale != "en-US" && locale != "nl-NL" {
		return "", errors.New("")
	}

	// Copy entries so as not to modify the input
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	// Pre-validate dates
	for _, e := range entriesCopy {
		if len(e.Date) != 10 || e.Date[4] != '-' || e.Date[7] != '-' {
			return "", errors.New("")
		}
	}

	if err := sortEntries(entriesCopy); err != nil {
		return "", err
	}

	var header string
	if locale == "en-US" {
		header = enHeader
	} else {
		header = nlHeader
	}

	lines := []string{header}
	for _, e := range entriesCopy {
		row, err := formatRow(e, currency, locale)
		if err != nil {
			return "", err
		}
		lines = append(lines, row)
	}

	return strings.Join(lines, "\n"), nil
}

// sortEntries sorts entries in place using date ascending, then description ascending, then change ascending.
func sortEntries(entries []Entry) error {
	layout := "2006-01-02"
	sort.SliceStable(entries, func(i, j int) bool {
		t1, err1 := time.Parse(layout, entries[i].Date)
		t2, err2 := time.Parse(layout, entries[j].Date)
		if err1 != nil || err2 != nil {
			return false
		}
		if !t1.Equal(t2) {
			return t1.Before(t2)
		}
		if entries[i].Description != entries[j].Description {
			return entries[i].Description < entries[j].Description
		}
		return entries[i].Change < entries[j].Change
	})
	return nil
}

// formatRow returns a formatted row for a given ledger entry.
func formatRow(e Entry, currency, locale string) (string, error) {
	// Parse date
	t, err := time.Parse("2006-01-02", e.Date)
	if err != nil {
		return "", errors.New("")
	}

	var dateStr string
	if locale == "en-US" {
		dateStr = t.Format(enDateLayout)
	} else if locale == "nl-NL" {
		dateStr = t.Format(nlDateLayout)
	} else {
		return "", errors.New("")
	}

	desc := truncate(e.Description, descWidth)

	changeStr, err := formatChange(e.Change, currency, locale)
	if err != nil {
		return "", err
	}

	// Build row: date left-justified (10), description left-justified (25), change field (padded to changeFieldWidth)
	row := fmt.Sprintf("%-10s | %-25s | %s", dateStr, desc, changeStr)
	return row, nil
}

// truncate shortens s to a maximum length. If s is longer than length, it truncates to (length - 3) and appends "...".
// If s is shorter, it pads it with spaces to reach the exact length.
func truncate(s string, length int) string {
	if len(s) <= length {
		return s + strings.Repeat(" ", length-len(s))
	}
	return s[:length-3] + "..."
}

// formatChange formats the change value according to locale and currency rules, then pads it to changeFieldWidth characters.
func formatChange(change int, currency, locale string) (string, error) {
	var unpadded string
	var err error
	if locale == "en-US" {
		unpadded, err = formatChangeUS(change, currency)
	} else if locale == "nl-NL" {
		unpadded, err = formatChangeNL(change, currency)
	} else {
		return "", errors.New("")
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%14s", unpadded)[1:], nil // ensure field width 13 by dropping 1 char from 14 padding
}

// In our case, expected change field width is 14 characters total from the formatted row (including the preceding " | ").
// However, the formula in our Sprintf for change field in the row uses %s, so the value we supply should be exactly 14 characters.
// We want to pad the unpadded value to width 14. So we do: fmt.Sprintf("%14s", unpadded).
// But our tests seem to require exactly the output as expected in the test cases. The test failure output indicates that the expected change field is of length 14. 
// To match the expected output exactly, let's directly use "%14s" without trimming.

func formatChange(change int, currency, locale string) (string, error) {
	var unpadded string
	var err error
	if locale == "en-US" {
		unpadded, err = formatChangeUS(change, currency)
	} else if locale == "nl-NL" {
		unpadded, err = formatChangeNL(change, currency)
	} else {
		return "", errors.New("")
	}
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%14s", unpadded), nil
}

// formatChangeUS implements the en-US formatting for monetary change.
func formatChangeUS(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ",")
	amount := fmt.Sprintf("%s.%02d", dollarStr, cents)

	var formatted string
	if negative {
		formatted = fmt.Sprintf("(%s%s)", getSymbol(currency), amount)
	} else {
		formatted = fmt.Sprintf("%s%s ", getSymbol(currency), amount)
	}

	return formatted, nil
}

// formatChangeNL implements the nl-NL formatting for monetary change.
func formatChangeNL(change int, currency string) (string, error) {
	negative := false
	absChange := change
	if change < 0 {
		negative = true
		absChange = -change
	}

	dollars := absChange / 100
	cents := absChange % 100

	dollarStr := formatThousand(dollars, ".")
	amount := fmt.Sprintf("%s,%02d", dollarStr, cents)

	var suffix string
	if negative {
		suffix = "-"
	} else {
		suffix = " "
	}

	formatted := fmt.Sprintf("%s %s%s", getSymbol(currency), amount, suffix)

	return formatted, nil
}

// getSymbol returns the currency symbol for the given currency.
func getSymbol(currency string) string {
	if currency == "USD" {
		return "$"
	} else if currency == "EUR" {
		return "€"
	}
	return ""
}

// formatThousand formats an integer with a thousands separator.
// It does not pad the most significant group.
func formatThousand(n int, sep string) string {
	s := strconv.Itoa(n)
	if len(s) <= 3 {
		return s
	}
	mod := len(s) % 3
	var result string
	if mod != 0 {
		result = s[:mod]
	} else {
		result = s[:3]
		mod = 3
	}
	for i := mod; i < len(s); i += 3 {
		result += sep + s[i:i+3]
	}
	return result
}

// CreateEntry parses the given date string (in "2006-01-02" format) and returns an Entry with the provided description and change.
func CreateEntry(date, description string, change int) (Entry, error) {
	_, err := time.Parse("2006-01-02", date)
	if err != nil {
		return Entry{}, err
	}
	return Entry{
		Date:        date,
		Description: description,
		Change:      change,
	}, nil
}


=== Test Results (Attempt 10) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/ledger [build failed]
FAIL

=== STDERR ===
# exercism/ledger [exercism/ledger.test]
./ledger.go:161:6: formatChange redeclared in this block
	./ledger.go:139:6: other declaration of formatChange


=== FINAL STATUS: FAILED ===