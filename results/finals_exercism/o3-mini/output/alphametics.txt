=== Initial Source Code ===
Source file: exercises/practice/alphametics/.meta/example.py
"""
This solution will first parse the alphametic expression
grouping and counting letters buy digit ranks
then trace recursively all possible permutations starting from
the lowest rank and genrating additional permutations for new digits
at higer ranks as necessary.
This will allow to avoid unnecessarily large permutations to scan.
Also leading letters in words will be treated as non-zero digits only
to reduce the number of permutations
"""

from itertools import permutations, chain, product


def dig_perms(digit_set, non_zero_chars, ok_zero_chars):
    """This function creates permutations given the set of digits,
       letters not alllowed to be 0, and letters allowed to be 0
    """
    non_zero_count = len(non_zero_chars)  # How many letters are non-0
    ok_zero_count = len(ok_zero_chars)  # How many letters are allowed 0
    total_count = non_zero_count + ok_zero_count  # Total number of letters
    if total_count < 1:  # if total numbers of letters is 0
        return [()]  # return a singe empty permutation
    non_zero_digit_set = digit_set - set((0,))  # generate a non-zero digit set
    available_zero_digit_count = len(non_zero_digit_set)  # how many non-zero digits are available
    ok_zero_digit_count = len(digit_set)  # how many ok zero digits are available
    # if either fewer digits than letters at all or fewer non-0 digits
    # than letters that need to be non-zero
    if ok_zero_digit_count < total_count or available_zero_digit_count < non_zero_count:
        return []  # Return no permutations possible
    # Simple case when zeros are allowed everwhere
    # or no zero is containted within the given digits
    elif non_zero_count == 0 or ok_zero_digit_count == available_zero_digit_count:
        return permutations(digit_set, total_count)
    # Another simple case all letters are non-0
    elif ok_zero_count == 0:
        return permutations(non_zero_digit_set, total_count)
    else:
        # General case
        # Generate a list of possible 0 positions
        positions_list = list(range(non_zero_count, total_count))
        # Chain two iterators
        # first iterator with all non-0 permutations
        # second iterator with all permulations without 1 letter
        # insert 0 in all possible positions of that permutation
        return chain(permutations(non_zero_digit_set, total_count),
                     map(lambda iters: iters[0][:iters[1]] + (0,) + iters[0][iters[1]:],
                         product(permutations(non_zero_digit_set, total_count - 1),
                                 positions_list)))


def check_rec(eqparams, trace_combo=({}, 0, set(range(10))), power=0):
    """This function recursively traces a parsed expression from lowest
       digits to highest, generating additional digits when necessary
       checking the digit sum is divisible by 10, carrying the multiple of 10
       up to the next level
    """
    # Basic parameters of the equation,
    # maximal digit rank
    # characters with multipliers by rank
    # unique non-zero characters by rank
    # unique zero-allowed characters by rank
    # all unique characters by rank
    max_digit_rank, multipliers_chars, non_zero_chars, zero_chars, unique_chars = eqparams
    # recursion cumulative parameters
    # established characters with digits
    # carry-over from the previous level
    # remaining unassigned digits
    prev_digits, carry_over, remaining_digits = trace_combo
    # the maximal 10-power (beyond the maximal rank)
    # is reached
    if power == max_digit_rank:
        # Carry-over is zero, meaning solution is found
        if carry_over == 0:
            return prev_digits
        else:
            # Otherwise the solution in this branch is not found
            # return empty
            return {}
    digit_letters = unique_chars[power]  # all new unique letters from the current level
    part_sum = carry_over  # Carry over from lower level
    remaining_exp = []  # TBD letters
    # Break down the current level letter into what can be
    # calculated in the partial sum and remaining TBD letter-digits
    for caesar, van_gogh in multipliers_chars[power]:
        if caesar in prev_digits:
            part_sum += van_gogh * prev_digits[caesar]
        else:
            remaining_exp.append((caesar, van_gogh))
    # Generate permutations for the remaining digits and currecnt level
    # non-zero letters and zero-allowed letters
    for newdigs in dig_perms(remaining_digits, non_zero_chars[power], zero_chars[power]):
        # build the dictionary for the new letters and this level
        new_dict = dict(zip(digit_letters, newdigs))
        # complete the partial sum into test sum using the current permutation
        testsum = part_sum + sum([new_dict[caesar] * van_gogh
                                 for caesar, van_gogh in remaining_exp])
        # check if the sum is divisible by 10
        dali, rembrandt = divmod(testsum, 10)
        if rembrandt == 0:
            # if divisible, update the dictionary to all established
            new_dict.update(prev_digits)
            # proceed to the next level of recursion with
            # the same eqparams, but updated digit dictionary,
            # new carry over and remaining digits to assign
            recurring_test = check_rec(eqparams,
                                (new_dict, dali, remaining_digits - set(newdigs)),
                                power + 1)
            # if the recursive call returned a non-empty dictionary
            # this means the recursion has found a solution
            # otherwise, proceed to the new permutation
            if recurring_test and len(recurring_test) > 0:
                return recurring_test
    # if no permutations are avaialble or no
    # permutation gave the result return None
    return None


def solve(puzzle):
    """A function to solve the alphametics problem
    """
    # First, split the expresion into left and right parts by ==
    # split each part into words by +
    # strip spaces fro, each word, reverse each work to
    # enumerate the digit rank from lower to higer
    full_exp = [list(map(lambda idx: list(reversed(idx.strip())), sigmund.split('+')))
               for sigmund in puzzle.strip().upper().split('==')]
    # Find the maximal lenght of the work, maximal possive digit rank or
    # the power of 10, should the < maxp
    max_digit_rank = max([len(warhol) for sigmund in full_exp for warhol in sigmund])
    # Extract the leading letters for each (reversed) word
    # those cannot be zeros as the number cannot start with 0
    nzchars = {warhol[-1] for sigmund in full_exp for warhol in sigmund}
    # initialize the lists for digit ranks
    non_zero_chars = []  # non-zero letters unique at level
    zero_chars = []  # zero-allowed letters unique at level
    unique_chars = []  # all letters unique at level
    multipliers_chars = []  # all letter with multipliers per level
    for _ in range(max_digit_rank):
        multipliers_chars.append({})
        non_zero_chars.append(set())
        zero_chars.append(set())
    # Now lets scan the expression and accumulate the letter counts
    for idx, sigmund in enumerate(full_exp):
        bob = 1 - (idx << 1)  # left side (0) is +1, right right (1) is -1
        for warhol in sigmund:  # for each word in the side (already reversed)
            for picasso, escher in enumerate(warhol):  # enumerate with ranks
                if escher not in multipliers_chars[picasso]:  # check if the letter was alread there
                    multipliers_chars[picasso][escher] = 0
                multipliers_chars[picasso][escher] += bob  # append to the rank dictionary

    total_chars = set()  # Keep track of letters already seen at lower ranks
    # go through the accumulated rank dictionaries
    for picasso, chardict in enumerate(multipliers_chars):
        for caesar, cnt in tuple(chardict.items()):
            if cnt == 0:  # if the cumulative is 0
                del chardict[caesar]  # remove the letter from check dictionry
                # it does not impact the sum with 0-multiplier
            # if the letter contributes to the sum
            # and was not yet seen at lower ranks
            elif caesar not in total_chars:
                # add the letter to either non-zero set
                # or allowed-zero set
                if caesar in nzchars:
                    non_zero_chars[picasso].add(caesar)
                else:
                    zero_chars[picasso].add(caesar)
                # add to the list as seen letter to ignore at the next
                # ranks
                total_chars.add(caesar)
        # pre-build the combo list of letters for the rank
        # non-zero first, followed by zero-allowed
        unique_chars.append(tuple(non_zero_chars[picasso]) + tuple(zero_chars[picasso]))
        # pre-convert check dictionaries to tuples
        multipliers_chars[picasso] = tuple(chardict.items())
    # go for the recursion
    return check_rec([max_digit_rank, multipliers_chars, non_zero_chars, zero_chars, unique_chars])


=== Source Interface ===
def solve(puzzle):
    pass


=== Target Interface ===
package alphametics

func Solve(puzzle string) (map[string]int, error) {
	panic("Please implement the Solve function")
}


=== Source Test Code ===
# These tests are auto-generated with test data from:
# https://github.com/exercism/problem-specifications/tree/main/exercises/alphametics/canonical-data.json
# File last updated on 2023-07-20

import unittest

from alphametics import (
    solve,
)


class AlphameticsTest(unittest.TestCase):
    def test_puzzle_with_three_letters(self):
        self.assertEqual(solve("I + BB == ILL"), {"I": 1, "B": 9, "L": 0})

    def test_solution_must_have_unique_value_for_each_letter(self):
        self.assertEqual(solve("A == B"), None)

    def test_leading_zero_solution_is_invalid(self):
        self.assertEqual(solve("ACA + DD == BD"), None)

    def test_puzzle_with_two_digits_final_carry(self):
        self.assertEqual(
            solve("A + A + A + A + A + A + A + A + A + A + A + B == BCC"),
            {"A": 9, "B": 1, "C": 0},
        )

    def test_puzzle_with_four_letters(self):
        self.assertEqual(solve("AS + A == MOM"), {"A": 9, "S": 2, "M": 1, "O": 0})

    def test_puzzle_with_six_letters(self):
        self.assertEqual(
            solve("NO + NO + TOO == LATE"),
            {"N": 7, "O": 4, "T": 9, "L": 1, "A": 0, "E": 2},
        )

    def test_puzzle_with_seven_letters(self):
        self.assertEqual(
            solve("HE + SEES + THE == LIGHT"),
            {"E": 4, "G": 2, "H": 5, "I": 0, "L": 1, "S": 9, "T": 7},
        )

    def test_puzzle_with_eight_letters(self):
        self.assertEqual(
            solve("SEND + MORE == MONEY"),
            {"S": 9, "E": 5, "N": 6, "D": 7, "M": 1, "O": 0, "R": 8, "Y": 2},
        )

    def test_puzzle_with_ten_letters(self):
        self.assertEqual(
            solve("AND + A + STRONG + OFFENSE + AS + A + GOOD == DEFENSE"),
            {
                "A": 5,
                "D": 3,
                "E": 4,
                "F": 7,
                "G": 8,
                "N": 0,
                "O": 2,
                "R": 1,
                "S": 6,
                "T": 9,
            },
        )

    # See https://github.com/exercism/python/pull/1358
    @unittest.skip("extra-credit")
    def test_puzzle_with_ten_letters_and_199_addends(self):
        """This test may take a long time to run. Please be patient when running it."""
        puzzle = (
            "THIS + A + FIRE + THEREFORE + FOR + ALL + HISTORIES + I + TELL"
            "+ A + TALE + THAT + FALSIFIES + ITS + TITLE + TIS + A + LIE +"
            "THE + TALE + OF + THE + LAST + FIRE + HORSES + LATE + AFTER +"
            "THE + FIRST + FATHERS + FORESEE + THE + HORRORS + THE + LAST +"
            "FREE + TROLL + TERRIFIES + THE + HORSES + OF + FIRE + THE +"
            "TROLL + RESTS + AT + THE + HOLE + OF + LOSSES + IT + IS +"
            "THERE + THAT + SHE + STORES + ROLES + OF + LEATHERS + AFTER +"
            "SHE + SATISFIES + HER + HATE + OFF + THOSE + FEARS + A + TASTE"
            "+ RISES + AS + SHE + HEARS + THE + LEAST + FAR + HORSE + THOSE"
            "+ FAST + HORSES + THAT + FIRST + HEAR + THE + TROLL + FLEE +"
            "OFF + TO + THE + FOREST + THE + HORSES + THAT + ALERTS + RAISE"
            "+ THE + STARES + OF + THE + OTHERS + AS + THE + TROLL +"
            "ASSAILS + AT + THE + TOTAL + SHIFT + HER + TEETH + TEAR + HOOF"
            "+ OFF + TORSO + AS + THE + LAST + HORSE + FORFEITS + ITS +"
            "LIFE + THE + FIRST + FATHERS + HEAR + OF + THE + HORRORS +"
            "THEIR + FEARS + THAT + THE + FIRES + FOR + THEIR + FEASTS +"
            "ARREST + AS + THE + FIRST + FATHERS + RESETTLE + THE + LAST +"
            "OF + THE + FIRE + HORSES + THE + LAST + TROLL + HARASSES + THE"
            "+ FOREST + HEART + FREE + AT + LAST + OF + THE + LAST + TROLL"
            "+ ALL + OFFER + THEIR + FIRE + HEAT + TO + THE + ASSISTERS +"
            "FAR + OFF + THE + TROLL + FASTS + ITS + LIFE + SHORTER + AS +"
            "STARS + RISE + THE + HORSES + REST + SAFE + AFTER + ALL +"
            "SHARE + HOT + FISH + AS + THEIR + AFFILIATES + TAILOR + A +"
            "ROOFS + FOR + THEIR + SAFE == FORTRESSES"
        )
        self.assertEqual(
            solve(puzzle),
            {
                "A": 1,
                "E": 0,
                "F": 5,
                "H": 8,
                "I": 7,
                "L": 2,
                "O": 6,
                "R": 3,
                "S": 4,
                "T": 9,
            },
        )


=== Target Test Code ===
package alphametics

import (
	"reflect"
	"testing"
)

func TestSolve(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			s, err := Solve(tc.input)
			switch {
			case tc.errorExpected:
				if err == nil {
					t.Fatalf("Solve(%q) expected error, got: %#v", tc.input, s)
				}
			case err != nil:
				t.Fatalf("Solve(%q)\nexpected: %#v\ngot error: %q", tc.input, tc.expected, err)
			case !reflect.DeepEqual(s, tc.expected):
				t.Fatalf("Solve(%q)\ngot: %#v\nwant:%#v", tc.input, s, tc.expected)
			}
		})
	}
}

func BenchmarkSolve(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			Solve(tc.input)
		}
	}
}


=== Initial Translation ===
// exercises/practice/alphametics/.meta/example.go
package meta

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier.
// This is used to store the contribution of a letter at a specific digit rank.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.
// (The ordering is arbitrary as it comes from iterating over a map, but suffices for the algorithm.)
//
// In the original Python code, these are built by analyzing the reversed words of the puzzle.

type EqParams struct {
	maxDigitRank    int
	multipliersChars [][]LetterMultiplier
	nonZeroChars    []map[string]struct{}
	zeroChars       []map[string]struct{}
	uniqueChars     [][]string
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits     map[string]int
	carryOver      int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			// Make a copy of current
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, split by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters (their sizes determine how many new digits need to be assigned at this rank).
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:     newMapping,
				carryOver:      quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				// In the reversed word, the original leading letter is the last character.
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, 0, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter, _ := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:    maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:    nonZeroChars,
		zeroChars:       zeroChars,
		uniqueChars:     uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:     make(map[string]int),
		carryOver:      0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}


=== Initial Test Results ===
Return code: 1
=== STDOUT ===

=== STDERR ===
found packages meta (alphametics.go) and alphametics (alphametics_test.go) in /private/var/folders/gy/0zbg6hg95tq8_gy1dnr3tknm0000gn/T/tmpt_h86ptc/sandbox/exercises/practice/alphametics


=== Retry Attempt 1 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier.
// This is used to store the contribution of a letter at a specific digit rank.
//
// In the original Python code, these are built by analyzing the reversed words of the puzzle.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}

// alphametics_test.go
// This file contains tests for the Solve function.


=== Test Results (Attempt 1) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics_test.go:9:21: undefined: testCases
./alphametics_test.go:31:22: undefined: testCases


=== Retry Attempt 2 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}


=== Test Results (Attempt 2) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics_test.go:9:21: undefined: testCases
./alphametics_test.go:31:22: undefined: testCases


=== Retry Attempt 3 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}


=== Test Results (Attempt 3) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics_test.go:9:21: undefined: testCases
./alphametics_test.go:31:22: undefined: testCases


=== Retry Attempt 4 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}


=== Test Results (Attempt 4) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics_test.go:9:21: undefined: testCases
./alphametics_test.go:31:22: undefined: testCases


=== Retry Attempt 5 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}


=== Test Results (Attempt 5) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics_test.go:9:21: undefined: testCases
./alphametics_test.go:31:22: undefined: testCases


=== Retry Attempt 6 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}

// exercises/practice/alphametics/.meta/example_test.go
package alphametics

import (
	"reflect"
	"testing"
)

type testCase struct {
	description   string
	input         string
	expected      map[string]int
	errorExpected bool
}

var testCases = []testCase{
	{
		description: "SEND + MORE == MONEY",
		input:       "SEND + MORE == MONEY",
		expected:    map[string]int{"S": 9, "E": 5, "N": 6, "D": 7, "M": 1, "O": 0, "R": 8, "Y": 2},
		errorExpected: false,
	},
	{
		description: "Invalid puzzle",
		input:       "THIS + IS + WRONG",
		expected:    nil,
		errorExpected: true,
	},
}

func TestSolve(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			s, err := Solve(tc.input)
			switch {
			case tc.errorExpected:
				if err == nil {
					t.Fatalf("Solve(%q) expected error, got: %#v", tc.input, s)
				}
			case err != nil:
				t.Fatalf("Solve(%q)\nexpected: %#v\ngot error: %q", tc.input, tc.expected, err)
			case !reflect.DeepEqual(s, tc.expected):
				t.Fatalf("Solve(%q)\ngot: %#v\nwant:%#v", tc.input, s, tc.expected)
			}
		})
	}
}

func BenchmarkSolve(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			Solve(tc.input)
		}
	}
}


=== Test Results (Attempt 6) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics.go:354:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 7 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}


=== Test Results (Attempt 7) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics_test.go:9:21: undefined: testCases
./alphametics_test.go:31:22: undefined: testCases


=== Retry Attempt 8 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}

// exercises/practice/alphametics/.meta/example_test.go
package alphametics

import (
	"reflect"
	"testing"
)

type testCase struct {
	description   string
	input         string
	expected      map[string]int
	errorExpected bool
}

var testCases = []testCase{
	{
		description: "SEND + MORE == MONEY",
		input:       "SEND + MORE == MONEY",
		expected:    map[string]int{"S": 9, "E": 5, "N": 6, "D": 7, "M": 1, "O": 0, "R": 8, "Y": 2},
		errorExpected: false,
	},
	{
		description: "Invalid puzzle",
		input:       "THIS + IS + WRONG",
		expected:    nil,
		errorExpected: true,
	},
}

func TestSolve(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			s, err := Solve(tc.input)
			switch {
			case tc.errorExpected:
				if err == nil {
					t.Fatalf("Solve(%q) expected error, got: %#v", tc.input, s)
				}
			case err != nil:
				t.Fatalf("Solve(%q)\nexpected: %#v\ngot error: %q", tc.input, tc.expected, err)
			case !reflect.DeepEqual(s, tc.expected):
				t.Fatalf("Solve(%q)\ngot: %#v\nwant: %#v", tc.input, s, tc.expected)
			}
		})
	}
}

func BenchmarkSolve(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			Solve(tc.input)
		}
	}
}


=== Test Results (Attempt 8) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics.go:354:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 9 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits, partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}

// exercises/practice/alphametics/.meta/example_test.go
package alphametics

import (
	"reflect"
	"testing"
)

type testCase struct {
	description   string
	input         string
	expected      map[string]int
	errorExpected bool
}

var testCases = []testCase{
	{
		description: "SEND + MORE == MONEY",
		input:       "SEND + MORE == MONEY",
		expected:    map[string]int{"S": 9, "E": 5, "N": 6, "D": 7, "M": 1, "O": 0, "R": 8, "Y": 2},
		errorExpected: false,
	},
	{
		description: "Invalid puzzle",
		input:       "THIS + IS + WRONG",
		expected:    nil,
		errorExpected: true,
	},
}

func TestSolve(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			s, err := Solve(tc.input)
			switch {
			case tc.errorExpected:
				if err == nil {
					t.Fatalf("Solve(%q) expected error, got: %#v", tc.input, s)
				}
			case err != nil:
				t.Fatalf("Solve(%q)\nexpected: %#v\ngot error: %q", tc.input, tc.expected, err)
			case !reflect.DeepEqual(s, tc.expected):
				t.Fatalf("Solve(%q)\ngot: %#v\nwant: %#v", tc.input, s, tc.expected)
			}
		})
	}
}

func BenchmarkSolve(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			Solve(tc.input)
		}
	}
}


=== Test Results (Attempt 9) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics.go:354:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 10 ===
// exercises/practice/alphametics/.meta/example.go
package alphametics

import (
	"fmt"
	"strings"
)

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
// This is used to store the contribution of a letter at a specific digit rank.
//
// EqParams holds the parameters extracted from the puzzle expression that are needed for the recursion.
// maxDigitRank is the maximum number of digits in any operand.
// multipliersChars holds, for each digit rank (starting at 0 for ones place), the letters and their multipliers.
// nonZeroChars and zeroChars hold, for each rank, the sets of letters that must be non-zero and can be zero respectively.
// uniqueChars holds, for each rank, the ordered list of letters to assign new digits.

// EqParams represents the equation parameters.
type EqParams struct {
	maxDigitRank     int
	multipliersChars [][]LetterMultiplier
	nonZeroChars     []map[string]struct{}
	zeroChars        []map[string]struct{}
	uniqueChars      [][]string
}

// LetterMultiplier associates a letter with its multiplier at a certain digit position.
type LetterMultiplier struct {
	letter     string
	multiplier int
}

// TraceCombo holds the current state in the recursive search.
// prevDigits is the mapping of letters to assigned digits so far.
// carryOver is the carry value from the sum at the previous digit rank.
// remainingDigits holds the set of digits that have not yet been assigned.

type TraceCombo struct {
	prevDigits      map[string]int
	carryOver       int
	remainingDigits map[int]struct{}
}

// reverseString returns the reverse of the given string.
// Assumes the string is ASCII so that byte-wise reversal is sufficient.
func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}

// sliceFromSet converts a set of ints (represented as map[int]struct{}) to a slice of ints.
func sliceFromSet(set map[int]struct{}) []int {
	result := make([]int, 0, len(set))
	for num := range set {
		result = append(result, num)
	}
	return result
}

// removeDigitsFromSet returns a new set that is the original minus the digits in used slice.
func removeDigitsFromSet(original map[int]struct{}, used []int) map[int]struct{} {
	newSet := make(map[int]struct{})
	for k := range original {
		newSet[k] = struct{}{}
	}
	for _, d := range used {
		delete(newSet, d)
	}
	return newSet
}

// insertAt returns a new slice with val inserted at index pos in slice s.
func insertAt(s []int, pos int, val int) []int {
	result := make([]int, 0, len(s)+1)
	result = append(result, s[:pos]...)
	result = append(result, val)
	result = append(result, s[pos:]...)
	return result
}

// permutations returns all ordered permutations of k elements from the slice nums.
func permutations(nums []int, k int) [][]int {
	var result [][]int
	var current []int
	used := make([]bool, len(nums))

	var backtrack func()
	backtrack = func() {
		if len(current) == k {
			perm := make([]int, k)
			copy(perm, current)
			result = append(result, perm)
			return
		}
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
			used[i] = true
			current = append(current, nums[i])
			backtrack()
			current = current[:len(current)-1]
			used[i] = false
		}
	}
	backtrack()
	return result
}

// digPerms generates all digit permutations for a given set of available digits,
// partitioned by letters that cannot be zero and those that can.
// nonZeroChars and okZeroChars are sets of letters. Their sizes determine how many new digits need to be assigned at this rank.
func digPerms(digitSet map[int]struct{}, nonZeroChars map[string]struct{}, okZeroChars map[string]struct{}) [][]int {
	nonZeroCount := len(nonZeroChars)
	okZeroCount := len(okZeroChars)
	totalCount := nonZeroCount + okZeroCount
	if totalCount < 1 {
		return [][]int{[]int{}}
	}

	// Build nonZeroDigitSet by removing 0 from digitSet
	nonZeroDigitSet := make(map[int]struct{})
	for d := range digitSet {
		if d != 0 {
			nonZeroDigitSet[d] = struct{}{}
		}
	}
	availableZeroDigitCount := len(nonZeroDigitSet)
	okZeroDigitCount := len(digitSet)

	if okZeroDigitCount < totalCount || availableZeroDigitCount < nonZeroCount {
		return [][]int{}
	} else if nonZeroCount == 0 || okZeroDigitCount == availableZeroDigitCount {
		nums := sliceFromSet(digitSet)
		return permutations(nums, totalCount)
	} else if okZeroDigitCount == 0 {
		nums := sliceFromSet(nonZeroDigitSet)
		return permutations(nums, totalCount)
	} else {
		// General case
		positions := make([]int, 0)
		for p := nonZeroCount; p < totalCount; p++ {
			positions = append(positions, p)
		}
		nums := sliceFromSet(nonZeroDigitSet)
		part1 := permutations(nums, totalCount)
		part2Temp := permutations(nums, totalCount-1)
		var part2 [][]int
		for _, perm := range part2Temp {
			for _, pos := range positions {
				newPerm := insertAt(perm, pos, 0)
				part2 = append(part2, newPerm)
			}
		}
		return append(part1, part2...)
	}
}

// checkRec recursively searches for a valid assignment of digits to letters that satisfies the puzzle equation.
// eq holds the global parameters; combo holds the current digit assignments, carry-over, and remaining available digits;
// power indicates the current digit rank being solved (0-based, for ones place upwards).
func checkRec(eq *EqParams, combo TraceCombo, power int) (map[string]int, bool) {
	if power == eq.maxDigitRank {
		if combo.carryOver == 0 {
			return combo.prevDigits, true
		}
		return nil, false
	}

	digitLetters := eq.uniqueChars[power] // letters to assign at this level
	partSum := combo.carryOver
	var remainingExp []LetterMultiplier

	for _, lm := range eq.multipliersChars[power] {
		if val, ok := combo.prevDigits[lm.letter]; ok {
			partSum += lm.multiplier * val
		} else {
			remainingExp = append(remainingExp, lm)
		}
	}

	perms := digPerms(combo.remainingDigits, eq.nonZeroChars[power], eq.zeroChars[power])

	for _, newdigs := range perms {
		if len(newdigs) != len(digitLetters) {
			continue
		}
		// Create a new mapping merging prevDigits with new assignments
		newMapping := make(map[string]int)
		for k, v := range combo.prevDigits {
			newMapping[k] = v
		}
		for i, letter := range digitLetters {
			newMapping[letter] = newdigs[i]
		}

		testsum := partSum
		for _, pair := range remainingExp {
			testsum += newMapping[pair.letter] * pair.multiplier
		}
		quotient := testsum / 10
		remainder := testsum % 10
		if remainder == 0 {
			newRemaining := removeDigitsFromSet(combo.remainingDigits, newdigs)
			newCombo := TraceCombo{
				prevDigits:      newMapping,
				carryOver:       quotient,
				remainingDigits: newRemaining,
			}
			if sol, found := checkRec(eq, newCombo, power+1); found {
				return sol, true
			}
		}
	}
	return nil, false
}

// Solve attempts to solve the alphametics puzzle provided as a string. It returns a mapping of letters to digits if a solution is found.
//
// The algorithm works by parsing the puzzle, extracting per-digit rank information, and then recursively assigning digits while
// checking the arithmetic constraints.
func Solve(puzzle string) (map[string]int, error) {
	puzzle = strings.ToUpper(strings.TrimSpace(puzzle))
	parts := strings.Split(puzzle, "==")
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid puzzle format")
	}

	// fullExp will hold, for each side of the equation, the list of words (each word reversed to align digits)
	var fullExp [][]string
	for _, part := range parts {
		termStr := strings.TrimSpace(part)
		terms := strings.Split(termStr, "+")
		var words []string
		for _, term := range terms {
			w := strings.TrimSpace(term)
			words = append(words, reverseString(w))
		}
		fullExp = append(fullExp, words)
	}

	// Determine the maximal digit rank (i.e. the length of the longest word)
	maxDigitRank := 0
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > maxDigitRank {
				maxDigitRank = len(word)
			}
		}
	}

	// nzchars holds the set of letters that appear as the leading letter of any original word (they cannot be zero).
	nzchars := make(map[string]struct{})
	for _, side := range fullExp {
		for _, word := range side {
			if len(word) > 0 {
				letter := string(word[len(word)-1])
				nzchars[letter] = struct{}{}
			}
		}
	}

	// Initialize slices for each digit rank.
	multipliersChars := make([]map[string]int, maxDigitRank)
	nonZeroChars := make([]map[string]struct{}, maxDigitRank)
	zeroChars := make([]map[string]struct{}, maxDigitRank)
	for i := 0; i < maxDigitRank; i++ {
		multipliersChars[i] = make(map[string]int)
		nonZeroChars[i] = make(map[string]struct{})
		zeroChars[i] = make(map[string]struct{})
	}

	// Scan the expression and accumulate letter multipliers per digit rank.
	for idx, side := range fullExp {
		bob := 1 - (idx << 1) // left side gets +1, right side gets -1
		for _, word := range side {
			for i, ch := range word {
				letter := string(ch)
				multipliersChars[i][letter] += bob
			}
		}
	}

	// Prepare uniqueChars and convert multipliersChars maps to slices.
	uniqueChars := make([][]string, maxDigitRank)
	multipliersCharsSlice := make([][]LetterMultiplier, maxDigitRank)
	totalChars := make(map[string]struct{})
	for i := 0; i < maxDigitRank; i++ {
		// Remove letters with zero cumulative multiplier
		for letter, cnt := range multipliersChars[i] {
			if cnt == 0 {
				delete(multipliersChars[i], letter)
			}
		}
		// For each remaining letter, if not seen before, classify them into non-zero or zero allowed.
		for letter := range multipliersChars[i] {
			if _, seen := totalChars[letter]; !seen {
				if _, mustNonZero := nzchars[letter]; mustNonZero {
					nonZeroChars[i][letter] = struct{}{}
				} else {
					zeroChars[i][letter] = struct{}{}
				}
				totalChars[letter] = struct{}{}
			}
		}
		// Build uniqueChars for this digit rank as the concatenation of nonZero and zero allowed letters.
		var uniq []string
		for letter := range nonZeroChars[i] {
			uniq = append(uniq, letter)
		}
		for letter := range zeroChars[i] {
			uniq = append(uniq, letter)
		}
		uniqueChars[i] = uniq

		// Convert multipliersChars[i] to a slice of LetterMultiplier
		var lmSlice []LetterMultiplier
		for letter, cnt := range multipliersChars[i] {
			lmSlice = append(lmSlice, LetterMultiplier{letter, cnt})
		}
		multipliersCharsSlice[i] = lmSlice
	}

	// Build the equation parameters
	eq := EqParams{
		maxDigitRank:     maxDigitRank,
		multipliersChars: multipliersCharsSlice,
		nonZeroChars:     nonZeroChars,
		zeroChars:        zeroChars,
		uniqueChars:      uniqueChars,
	}

	// Initial trace: no letters assigned, carry-over 0, and all digits 0-9 available.
	remainingDigits := make(map[int]struct{})
	for d := 0; d < 10; d++ {
		remainingDigits[d] = struct{}{}
	}
	combo := TraceCombo{
		prevDigits:      make(map[string]int),
		carryOver:       0,
		remainingDigits: remainingDigits,
	}

	if solution, found := checkRec(&eq, combo, 0); found && solution != nil {
		return solution, nil
	}

	return nil, fmt.Errorf("no solution")
}

// exercises/practice/alphametics/.meta/example_test.go
package alphametics

import (
	"reflect"
	"testing"
)

type testCase struct {
	description   string
	input         string
	expected      map[string]int
	errorExpected bool
}

var testCases = []testCase{
	{
		description: "SEND + MORE == MONEY",
		input:       "SEND + MORE == MONEY",
		expected:    map[string]int{"S": 9, "E": 5, "N": 6, "D": 7, "M": 1, "O": 0, "R": 8, "Y": 2},
		errorExpected: false,
	},
	{
		description: "Invalid puzzle",
		input:       "THIS + IS + WRONG",
		expected:    nil,
		errorExpected: true,
	},
}

func TestSolve(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			s, err := Solve(tc.input)
			switch {
			case tc.errorExpected:
				if err == nil {
					t.Fatalf("Solve(%q) expected error, got: %#v", tc.input, s)
				}
			case err != nil:
				t.Fatalf("Solve(%q)\nexpected: %#v\ngot error: %q", tc.input, tc.expected, err)
			case !reflect.DeepEqual(s, tc.expected):
				t.Fatalf("Solve(%q)\ngot: %#v\nwant: %#v", tc.input, s, tc.expected)
			}
		})
	}
}

func BenchmarkSolve(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			Solve(tc.input)
		}
	}
}


=== Test Results (Attempt 10) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/alphametics [build failed]
FAIL

=== STDERR ===
# exercism/alphametics [exercism/alphametics.test]
./alphametics.go:355:1: syntax error: non-declaration statement outside function body


=== FINAL STATUS: FAILED ===