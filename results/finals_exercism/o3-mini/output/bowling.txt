=== Initial Source Code ===
Source file: exercises/practice/bowling/.meta/example.py
MAX_FRAME = 10


class Frame:
    def __init__(self, idx):
        self.idx = idx
        self.throws = []

    @property
    def total_pins(self):
        """Total pins knocked down in a frame."""
        return sum(self.throws)

    def is_strike(self):
        return self.total_pins == 10 and len(self.throws) == 1

    def is_spare(self):
        return self.total_pins == 10 and len(self.throws) == 2

    def is_open(self):
        return self.total_pins < 10 and len(self.throws) == 2

    def is_closed(self):
        """Return whether a frame is over."""
        return self.total_pins == 10 or len(self.throws) == 2

    def throw(self, pins):
        if self.total_pins + pins > 10:
            raise ValueError("a frame's rolls cannot exceed 10")
        self.throws.append(pins)

    def score(self, next_throws):
        result = self.total_pins
        if self.is_strike():
            result += sum(next_throws[:2])
        elif self.is_spare():
            result += sum(next_throws[:1])
        return result


class BowlingGame:
    def __init__(self):
        self.current_frame_idx = 0
        self.bonus_throws = []
        self.frames = [Frame(idx) for idx in range(MAX_FRAME)]

    @property
    def current_frame(self):
        return self.frames[self.current_frame_idx]

    def next_throws(self, frame_idx):
        """Return a frame's next throws in the form of a list."""
        throws = []
        for idx in range(frame_idx + 1, MAX_FRAME):
            throws.extend(self.frames[idx].throws)
        throws.extend(self.bonus_throws)
        return throws

    def roll_bonus(self, pins):
        tenth_frame = self.frames[-1]
        if tenth_frame.is_open():
            raise IndexError('cannot throw bonus with an open tenth frame')

        self.bonus_throws.append(pins)

        # Check against invalid fill balls, e.g. [3, 10]
        if (len(self.bonus_throws) == 2 and self.bonus_throws[0] != 10 and
                sum(self.bonus_throws) > 10):
            raise ValueError('invalid fill balls')

        # Check if there are more bonuses than it should be
        if tenth_frame.is_strike() and len(self.bonus_throws) > 2:
            raise IndexError(
                'wrong number of fill balls when the tenth frame is a strike')
        elif tenth_frame.is_spare() and len(self.bonus_throws) > 1:
            raise IndexError(
                'wrong number of fill balls when the tenth frame is a spare')

    def roll(self, pins):
        if not 0 <= pins <= 10:
            raise ValueError('invalid pins')
        elif self.current_frame_idx == MAX_FRAME:
            self.roll_bonus(pins)
        else:
            self.current_frame.throw(pins)
            if self.current_frame.is_closed():
                self.current_frame_idx += 1

    def score(self):
        if self.current_frame_idx < MAX_FRAME:
            raise IndexError('frame less than 10')
        if self.frames[-1].is_spare() and len(self.bonus_throws) != 1:
            raise IndexError(
                'one bonus must be rolled when the tenth frame is spare')
        if self.frames[-1].is_strike() and len(self.bonus_throws) != 2:
            raise IndexError(
                'two bonuses must be rolled when the tenth frame is strike')
        return sum(frame.score(self.next_throws(frame.idx))
                   for frame in self.frames)


=== Source Interface ===
class BowlingGame:
    def __init__(self):
        pass

    def roll(self, pins):
        pass

    def score(self):
        pass


=== Target Interface ===
package bowling

// Define the Game type here.

func NewGame() *Game {
	panic("Please implement the NewGame function")
}

func (g *Game) Roll(pins int) error {
	panic("Please implement the Roll function")
}

func (g *Game) Score() (int, error) {
	panic("Please implement the Score function")
}


=== Source Test Code ===
# These tests are auto-generated with test data from:
# https://github.com/exercism/problem-specifications/tree/main/exercises/bowling/canonical-data.json
# File last updated on 2023-07-21

import unittest

from bowling import (
    BowlingGame,
)


class BowlingTest(unittest.TestCase):
    def roll_new_game(self, rolls):
        game = BowlingGame()
        for roll in rolls:
            game.roll(roll)
        return game

    def test_should_be_able_to_score_a_game_with_all_zeros(self):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 0)

    def test_should_be_able_to_score_a_game_with_no_strikes_or_spares(self):
        rolls = [3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 90)

    def test_a_spare_followed_by_zeros_is_worth_ten_points(self):
        rolls = [6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 10)

    def test_points_scored_in_the_roll_after_a_spare_are_counted_twice(self):
        rolls = [6, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 16)

    def test_consecutive_spares_each_get_a_one_roll_bonus(self):
        rolls = [5, 5, 3, 7, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 31)

    def test_a_spare_in_the_last_frame_gets_a_one_roll_bonus_that_is_counted_once(self):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 3, 7]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 17)

    def test_a_strike_earns_ten_points_in_a_frame_with_a_single_roll(self):
        rolls = [10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 10)

    def test_points_scored_in_the_two_rolls_after_a_strike_are_counted_twice_as_a_bonus(
        self,
    ):
        rolls = [10, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 26)

    def test_consecutive_strikes_each_get_the_two_roll_bonus(self):
        rolls = [10, 10, 10, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 81)

    def test_a_strike_in_the_last_frame_gets_a_two_roll_bonus_that_is_counted_once(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 7, 1]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 18)

    def test_rolling_a_spare_with_the_two_roll_bonus_does_not_get_a_bonus_roll(self):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 7, 3]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 20)

    def test_strikes_with_the_two_roll_bonus_do_not_get_bonus_rolls(self):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 10]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 30)

    def test_last_two_strikes_followed_by_only_last_bonus_with_non_strike_points(self):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 0, 1]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 31)

    def test_a_strike_with_the_one_roll_bonus_after_a_spare_in_the_last_frame_does_not_get_a_bonus(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 3, 10]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 20)

    def test_all_strikes_is_a_perfect_game(self):
        rolls = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 300)

    def test_rolls_cannot_score_negative_points(self):
        rolls = []
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(-1)

    def test_a_roll_cannot_score_more_than_10_points(self):
        rolls = []
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(11)

    def test_two_rolls_in_a_frame_cannot_score_more_than_10_points(self):
        rolls = [5]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(6)

    def test_bonus_roll_after_a_strike_in_the_last_frame_cannot_score_more_than_10_points(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(11)

    def test_two_bonus_rolls_after_a_strike_in_the_last_frame_cannot_score_more_than_10_points(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(6)

    def test_two_bonus_rolls_after_a_strike_in_the_last_frame_can_score_more_than_10_points_if_one_is_a_strike(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10, 6]
        game = self.roll_new_game(rolls)
        self.assertEqual(game.score(), 26)

    def test_the_second_bonus_rolls_after_a_strike_in_the_last_frame_cannot_be_a_strike_if_the_first_one_is_not_a_strike(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 6]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(10)

    def test_second_bonus_roll_after_a_strike_in_the_last_frame_cannot_score_more_than_10_points(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(11)

    def test_an_unstarted_game_cannot_be_scored(self):
        rolls = []
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.score()

    def test_an_incomplete_game_cannot_be_scored(self):
        rolls = [0, 0]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.score()

    def test_cannot_roll_if_game_already_has_ten_frames(self):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(0)

    def test_bonus_rolls_for_a_strike_in_the_last_frame_must_be_rolled_before_score_can_be_calculated(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.score()

    def test_both_bonus_rolls_for_a_strike_in_the_last_frame_must_be_rolled_before_score_can_be_calculated(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.score()

    def test_bonus_roll_for_a_spare_in_the_last_frame_must_be_rolled_before_score_can_be_calculated(
        self,
    ):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 3]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.score()

    def test_cannot_roll_after_bonus_roll_for_spare(self):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 3, 2]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(2)

    def test_cannot_roll_after_bonus_rolls_for_strike(self):
        rolls = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 3, 2]
        game = self.roll_new_game(rolls)
        with self.assertRaisesWithMessage(Exception):
            game.roll(2)

    # Utility functions
    def assertRaisesWithMessage(self, exception):
        return self.assertRaisesRegex(exception, r".+")


=== Target Test Code ===
package bowling

import "testing"

const previousRollErrorMessage = `
	Unexpected error occurred: %v
	while applying the previous rolls for the
	test case: %v
	The error was returned from Roll(%d) for previousRolls[%d].`

func applyPreviousRolls(g *Game, rolls []int) (index, pins int, err error) {
	for index, pins := range rolls {
		if err := g.Roll(pins); err != nil {
			return index, pins, err
		}
	}
	return 0, 0, nil
}

func TestRoll(t *testing.T) {
	for _, tc := range rollTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyPreviousRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(previousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			err = g.Roll(tc.roll)
			if tc.valid && err != nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v returned unexpected error: %v", tc.roll, tc.previousRolls, err)
			} else if !tc.valid && err == nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v expected an error, got nil\n\tExplanation: %s", tc.roll, tc.previousRolls, tc.explainText)
			}
		})
	}
}

func TestScore(t *testing.T) {
	for _, tc := range scoreTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyPreviousRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(previousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			score, err := g.Score()
			switch {
			case !tc.valid:
				if err == nil {
					t.Fatalf("Score() after Previous Rolls: %#v expected an error, got score %d\n\tExplanation: %s", tc.previousRolls, score, tc.explainText)
				}
			case err != nil:
				t.Fatalf("Score() after Previous Rolls: %#v returned error: %v, want: %d", tc.previousRolls, err, tc.score)
			case score != tc.score:
				t.Fatalf("Score() after Previous Rolls: %#v = %d, want: %d", tc.previousRolls, score, tc.score)
			}
		})
	}
}


=== Initial Translation ===
// exercises/practice/bowling/.meta/example.go
package meta

import (
	"errors"
	"fmt"
)

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and two balls thrown).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two balls thrown).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if the added throw would exceed 10 pins in the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from next throws if applicable.
// nextThrows is a slice of subsequent rolls.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		bonus := sumInts(nextThrows, 2)
		score += bonus
	} else if f.IsSpare() {
		bonus := sumInts(nextThrows, 1)
		score += bonus
	}
	return score
}

// sumInts sums up to count elements from the slice. If there are fewer elements, it sums what is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// BowlingGame represents a complete game of bowling.
type BowlingGame struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new BowlingGame with 10 frames.
func NewGame() *BowlingGame {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &BowlingGame{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (bg *BowlingGame) currentFrame() *Frame {
	if bg.currentFrameIdx < MaxFrame {
		return bg.frames[bg.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from frame index + 1
// and then appending bonus throws.
func (bg *BowlingGame) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, bg.frames[i].Throws...)
	}
	next = append(next, bg.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the 10th frame.
func (bg *BowlingGame) rollBonus(pins int) error {
	tenthFrame := bg.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}

	bg.bonusThrows = append(bg.bonusThrows, pins)

	// Check against invalid fill balls, e.g. [3, 10]
	if len(bg.bonusThrows) == 2 && bg.bonusThrows[0] != 10 && (bg.bonusThrows[0]+bg.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}

	// Check if there are more bonuses than it should be
	if tenthFrame.IsStrike() && len(bg.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(bg.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}

	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the appropriate frame or bonus.
func (bg *BowlingGame) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if bg.currentFrameIdx == MaxFrame {
		return bg.rollBonus(pins)
	}

	err := bg.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if bg.currentFrame().IsClosed() {
		bg.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game. It returns an error if the game is incomplete or bonus throws are missing/extra.
func (bg *BowlingGame) Score() (int, error) {
	if bg.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}

	tenthFrame := bg.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(bg.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(bg.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}

	total := 0
	for _, frame := range bg.frames {
		total += frame.Score(bg.nextThrows(frame.Idx))
	}
	return total, nil
}

// Example usage of the BowlingGame implementation
func main() {
	game := NewGame()
	// This is an example usage. Typically, tests would drive the game state.
	// Here we simulate a game with all strikes.
	for i := 0; i < MaxFrame; i++ {
		if err := game.Roll(10); err != nil {
			fmt.Println("Error rolling:", err)
			return
		}
	}

	// Now roll bonus throws for the 10th frame strike
	if err := game.Roll(10); err != nil {
		fmt.Println("Error rolling bonus:", err)
		return
	}
	if err := game.Roll(10); err != nil {
		fmt.Println("Error rolling bonus:", err)
		return
	}

	score, err := game.Score()
	if err != nil {
		fmt.Println("Error scoring:", err)
	} else {
		fmt.Println("Final score:", score) // Should print 300 for a perfect game
	}
}


=== Initial Test Results ===
Return code: 1
=== STDOUT ===

=== STDERR ===
found packages meta (bowling.go) and bowling (bowling_test.go) in /private/var/folders/gy/0zbg6hg95tq8_gy1dnr3tknm0000gn/T/tmpt_h86ptc/sandbox/exercises/practice/bowling


=== Retry Attempt 1 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import (
	"errors"
	"fmt"
)

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and two balls thrown).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two balls thrown).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if the added throw would exceed 10 pins in the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from next throws if applicable.
// nextThrows is a slice of subsequent rolls.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to count elements from the slice. If there are fewer elements, it sums what is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from frame index + 1
// and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the 10th frame.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}

	g.bonusThrows = append(g.bonusThrows, pins)

	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}

	// Check if there are more bonuses than it should be
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}

	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the appropriate frame or bonus.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game. It returns an error if the game is incomplete or bonus throws are missing/extra.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}

	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}

	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}

func main() {
	game := NewGame()
	// Example usage: simulate a game with all strikes.
	for i := 0; i < MaxFrame; i++ {
		if err := game.Roll(10); err != nil {
			fmt.Println("Error rolling:", err)
			return
		}
	}

	// Roll bonus throws for the 10th frame strike
	if err := game.Roll(10); err != nil {
		fmt.Println("Error rolling bonus:", err)
		return
	}
	if err := game.Roll(10); err != nil {
		fmt.Println("Error rolling bonus:", err)
		return
	}

	score, err := game.Score()
	if err != nil {
		fmt.Println("Error scoring:", err)
	} else {
		fmt.Println("Final score:", score) // Should print 300 for a perfect game
	}
}

// exercises/practice/bowling/.meta/example_test.go
package bowling

import (
	"reflect"
	"testing"
)

const previousRollErrorMessage = `
	Unexpected error occurred: %v
	while applying the previous rolls for the
	test case: %v
	The error was returned from Roll(%d) for previousRolls[%d].`

// rollTestCase defines a test case for the Roll function.
type rollTestCase struct {
	description   string
	previousRolls []int
	roll          int
	valid         bool
	explainText   string
}

var rollTestCases = []rollTestCase{
	{
		description:   "Valid roll after a series of valid previous rolls",
		previousRolls: []int{3, 4},
		roll:          3,
		valid:         true,
		explainText:   "Should accept valid roll",
	},
	{
		description:   "Invalid roll with wrong pin count",
		previousRolls: []int{3, 4},
		roll:          -1,
		valid:         false,
		explainText:   "Should reject negative pins",
	},
	{
		description:   "Invalid roll exceeding frame limit",
		previousRolls: []int{5, 6},
		roll:          5,
		valid:         false,
		explainText:   "Should reject roll causing frame total to exceed 10",
	},
}

func applyPreviousRolls(g *Game, rolls []int) (int, int, error) {
	for index, pins := range rolls {
		if err := g.Roll(pins); err != nil {
			return index, pins, err
		}
	}
	return 0, 0, nil
}

func TestRoll(t *testing.T) {
	for _, tc := range rollTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyPreviousRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(previousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			err = g.Roll(tc.roll)
			if tc.valid && err != nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v returned unexpected error: %v", tc.roll, tc.previousRolls, err)
			} else if !tc.valid && err == nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v expected an error, got nil\n\tExplanation: %s", tc.roll, tc.previousRolls, tc.explainText)
			}
		})
	}
}

type scoreTestCase struct {
	description   string
	previousRolls []int
	score         int
	valid         bool
	explainText   string
}

var scoreTestCases = []scoreTestCase{
	{
		description:   "Perfect game",
		previousRolls: perfectGameRolls(),
		score:         300,
		valid:         true,
		explainText:   "A perfect game should score 300",
	},
	{
		description:   "Incomplete game",
		previousRolls: []int{10, 10},
		score:         0,
		valid:         false,
		explainText:   "Game is incomplete, should return error",
	},
}

func perfectGameRolls() []int {
	rolls := []int{}
	for i := 0; i < 12; i++ {
		rolls = append(rolls, 10)
	}
	return rolls
}

func TestScore(t *testing.T) {
	for _, tc := range scoreTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyPreviousRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(previousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			score, err := g.Score()
			switch {
			case !tc.valid:
				if err == nil {
					t.Fatalf("Score() after Previous Rolls: %#v expected an error, got score %d\n\tExplanation: %s", tc.previousRolls, score, tc.explainText)
				}
			case err != nil:
				t.Fatalf("Score() after Previous Rolls: %#v returned error: %v, want: %d", tc.previousRolls, err, tc.score)
			case score != tc.score:
				t.Fatalf("Score() after Previous Rolls: %#v = %d, want: %d", tc.previousRolls, score, tc.score)
			}
		})
	}
}


=== Test Results (Attempt 1) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling.go:211:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 2 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and two balls thrown).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two balls thrown).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if the added throw would exceed 10 pins in the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from next throws if applicable.
// nextThrows is a slice of subsequent rolls.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to count elements from the slice. If there are fewer elements, it sums what is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from frame index + 1 and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the 10th frame.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonuses than it should be
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the appropriate frame or bonus.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game. It returns an error if the game is incomplete or bonus throws are missing/extra.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}


=== Test Results (Attempt 2) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling_test.go:21:21: undefined: rollTestCases
./bowling_test.go:39:21: undefined: scoreTestCases


=== Retry Attempt 3 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and two balls thrown).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two balls thrown).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if the added throw would exceed 10 pins in the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from next throws if applicable.
// nextThrows is a slice of subsequent rolls.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to count elements from the slice. If there are fewer elements, it sums what is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from frame index + 1 and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the 10th frame.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonuses than it should be
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the appropriate frame or bonus.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game. It returns an error if the game is incomplete or bonus throws are missing/extra.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}


=== Test Results (Attempt 3) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling_test.go:21:21: undefined: rollTestCases
./bowling_test.go:39:21: undefined: scoreTestCases


=== Retry Attempt 4 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and two balls thrown).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two balls thrown).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if the added throw would exceed 10 pins in the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from next throws if applicable.
// nextThrows is a slice of subsequent rolls.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to count elements from the slice. If there are fewer elements, it sums what is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from frame index + 1 and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the 10th frame.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonuses than it should be
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the appropriate frame or bonus.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game. It returns an error if the game is incomplete or bonus throws are missing/extra.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}


=== Test Results (Attempt 4) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling_test.go:21:21: undefined: rollTestCases
./bowling_test.go:39:21: undefined: scoreTestCases


=== Retry Attempt 5 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and two balls thrown).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two balls thrown).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if the added throw would exceed 10 pins in the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from next throws if applicable.
// nextThrows is a slice of subsequent rolls.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to count elements from the slice. If there are fewer elements, it sums what is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from frame index + 1
// and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the 10th frame.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonuses than it should be
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the appropriate frame or bonus.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game. It returns an error if the game is incomplete or bonus throws are missing/extra.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}

// exercises/practice/bowling/.meta/example_test.go
package bowling

import (
	"testing"
)

// rollTestCase defines a test case for the Roll function.
type rollTestCase struct {
	description   string
	previousRolls []int
	roll          int
	valid         bool
	explainText   string
}

var rollTestCases = []rollTestCase{
	{
		description:   "Valid roll after a series of valid previous rolls",
		previousRolls: []int{3, 4},
		roll:          3,
		valid:         true,
		explainText:   "Should accept valid roll",
	},
	{
		description:   "Invalid roll with wrong pin count",
		previousRolls: []int{3, 4},
		roll:          -1,
		valid:         false,
		explainText:   "Should reject negative pins",
	},
	{
		description:   "Invalid roll exceeding frame limit",
		previousRolls: []int{5, 6},
		roll:          5,
		valid:         false,
		explainText:   "Should reject roll causing frame total to exceed 10",
	},
}

// scoreTestCase defines a test case for the Score function.
type scoreTestCase struct {
	description   string
	previousRolls []int
	score         int
	valid         bool
	explainText   string
}

func perfectGameRolls() []int {
	rolls := []int{}
	for i := 0; i < 12; i++ {
		rolls = append(rolls, 10)
	}
	return rolls
}

var scoreTestCases = []scoreTestCase{
	{
		description:   "Perfect game",
		previousRolls: perfectGameRolls(),
		score:         300,
		valid:         true,
		explainText:   "A perfect game should score 300",
	},
	{
		description:   "Incomplete game",
		previousRolls: []int{10, 10},
		score:         0,
		valid:         false,
		explainText:   "Game is incomplete, should return error",
	},
}

const previousRollErrorMessage = ` + "\n" + `
	Unexpected error occurred: %v
	while applying the previous rolls for the
	test case: %v
	The error was returned from Roll(%d) for previousRolls[%d].`

func applyPreviousRolls(g *Game, rolls []int) (int, int, error) {
	for index, pins := range rolls {
		if err := g.Roll(pins); err != nil {
			return index, pins, err
		}
	}
	return 0, 0, nil
}

func TestRoll(t *testing.T) {
	for _, tc := range rollTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyPreviousRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(previousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			err = g.Roll(tc.roll)
			if tc.valid && err != nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v returned unexpected error: %v", tc.roll, tc.previousRolls, err)
			} else if !tc.valid && err == nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v expected an error, got nil\n\tExplanation: %s", tc.roll, tc.previousRolls, tc.explainText)
			}
		})
	}
}

func TestScore(t *testing.T) {
	for _, tc := range scoreTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyPreviousRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(previousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			score, err := g.Score()
			switch {
			case !tc.valid:
				if err == nil {
					t.Fatalf("Score() after Previous Rolls: %#v expected an error, got score %d\n\tExplanation: %s", tc.previousRolls, score, tc.explainText)
				}
			case err != nil:
				t.Fatalf("Score() after Previous Rolls: %#v returned error: %v, want: %d", tc.previousRolls, err, tc.score)
			case score != tc.score:
				t.Fatalf("Score() after Previous Rolls: %#v = %d, want: %d", tc.previousRolls, score, tc.score)
			}
		})
	}
}


=== Test Results (Attempt 5) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling.go:180:1: syntax error: non-declaration statement outside function body
./bowling.go:254:2: syntax error: non-declaration statement outside function body
./bowling.go:257:61: string not terminated


=== Retry Attempt 6 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and two balls thrown).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two balls thrown).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if adding the throw would exceed 10 pins in the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from next throws if applicable.
// nextThrows is a slice of subsequent rolls.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to count elements from the slice. If there are fewer than count elements, it sums what is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from frame index + 1 and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the 10th frame.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonuses than allowed
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the appropriate frame or bonus.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game. It returns an error if the game is incomplete or bonus throws are missing/extra.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}

// exercises/practice/bowling/.meta/example_test.go
package bowling

import "testing"

// rollTestCase defines a test case for the Roll function.
type rollTestCase struct {
	description   string
	previousRolls []int
	roll          int
	valid         bool
	explainText   string
}

var rollTestCases = []rollTestCase{
	{
		description:   "Valid roll after a series of valid previous rolls",
		previousRolls: []int{3, 4},
		roll:          3,
		valid:         true,
		explainText:   "Should accept valid roll",
	},
	{
		description:   "Invalid roll with wrong pin count",
		previousRolls: []int{3, 4},
		roll:          -1,
		valid:         false,
		explainText:   "Should reject negative pins",
	},
	{
		description:   "Invalid roll exceeding frame limit",
		previousRolls: []int{5, 6},
		roll:          5,
		valid:         false,
		explainText:   "Should reject roll causing frame total to exceed 10",
	},
}

// scoreTestCase defines a test case for the Score function.
type scoreTestCase struct {
	description   string
	previousRolls []int
	score         int
	valid         bool
	explainText   string
}

func perfectGameRolls() []int {
	rolls := []int{}
	for i := 0; i < 12; i++ {
		rolls = append(rolls, 10)
	}
	return rolls
}

var scoreTestCases = []scoreTestCase{
	{
		description:   "Perfect game",
		previousRolls: perfectGameRolls(),
		score:         300,
		valid:         true,
		explainText:   "A perfect game should score 300",
	},
	{
		description:   "Incomplete game",
		previousRolls: []int{10, 10},
		score:         0,
		valid:         false,
		explainText:   "Game is incomplete, should return error",
	},
}

const testPreviousRollErrorMessage = "\n	Unexpected error occurred: %v\n\twhile applying the previous rolls for the\n\ttest case: %v\n\tThe error was returned from Roll(%d) for previousRolls[%d]."

func applyTestRolls(g *Game, rolls []int) (int, int, error) {
	for index, pins := range rolls {
		if err := g.Roll(pins); err != nil {
			return index, pins, err
		}
	}
	return 0, 0, nil
}

func TestRoll(t *testing.T) {
	for _, tc := range rollTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyTestRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(testPreviousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			err = g.Roll(tc.roll)
			if tc.valid && err != nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v returned unexpected error: %v", tc.roll, tc.previousRolls, err)
			} else if !tc.valid && err == nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v expected an error, got nil\n\tExplanation: %s", tc.roll, tc.previousRolls, tc.explainText)
			}
		})
	}
}

func TestScore(t *testing.T) {
	for _, tc := range scoreTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyTestRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(testPreviousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			score, err := g.Score()
			switch {
			case !tc.valid:
				if err == nil {
					t.Fatalf("Score() after Previous Rolls: %#v expected an error, got score %d\n\tExplanation: %s", tc.previousRolls, score, tc.explainText)
				}
			case err != nil:
				t.Fatalf("Score() after Previous Rolls: %#v returned error: %v, want: %d", tc.previousRolls, err, tc.score)
			case score != tc.score:
				t.Fatalf("Score() after Previous Rolls: %#v = %d, want: %d", tc.previousRolls, score, tc.score)
			}
		})
	}
}


=== Test Results (Attempt 6) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling.go:179:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 7 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
// It tracks the index of the frame and the pins knocked down in each throw.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and exactly two throws thrown).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two throws have been made).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if adding the throw would exceed 10 pins in total for the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from subsequent throws if applicable.
// nextThrows is a slice of subsequent rolls used for bonus calculation.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to count elements from the slice.
// If there are fewer elements than count, it sums what is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
// It manages the frames, the current frame index, and bonus throws for the tenth frame.
// This implementation assumes a game has exactly 10 frames.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from the frame after frameIdx, then bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the tenth frame.
// It validates that bonus rolls are allowed based on the tenth frame and their cumulative pins.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonuses than allowed
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the current frame
// or as a bonus if all frames have been played.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game.
// It returns an error if the game is incomplete or if bonus throws are missing/extra based on the tenth frame.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}


=== Test Results (Attempt 7) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling_test.go:21:21: undefined: rollTestCases
./bowling_test.go:39:21: undefined: scoreTestCases


=== Retry Attempt 8 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
// It tracks the frame index and the pins knocked down in each throw.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and exactly two throws have been made).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two throws have been made).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if adding the throw would exceed 10 pins in total for the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from subsequent throws if applicable.
// The nextThrows parameter contains subsequent rolls used for bonus calculation.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to 'count' elements from the slice.
// If there are fewer than 'count' elements, it sums whatever is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
// It manages the frames, the current frame index, and bonus throws for the tenth frame.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from the frame after frameIdx and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the tenth frame.
// It validates that bonus rolls are allowed based on the tenth frame outcome and their cumulative pins.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonus throws than allowed
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the current frame
// or as a bonus if all frames have been completed.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game.
// It returns an error if the game is incomplete or if bonus throws are missing/extra for the tenth frame.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}


=== Test Results (Attempt 8) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling_test.go:21:21: undefined: rollTestCases
./bowling_test.go:39:21: undefined: scoreTestCases


=== Retry Attempt 9 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
// It tracks the frame index and the pins knocked down in each throw.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and exactly two throws have been made).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two throws have been made).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame. It returns an error if adding the throw would exceed 10 pins in total for the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from subsequent throws if applicable.
// The nextThrows parameter contains subsequent rolls used for bonus calculation.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to 'count' elements from the slice.
// If there are fewer than 'count' elements, it sums whatever is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
// It manages the frames, the current frame index, and bonus throws for the tenth frame.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from the frame after frameIdx
// and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the tenth frame.
// It validates that bonus rolls are allowed based on the tenth frame outcome and their cumulative pins.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonus throws than allowed
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game. It validates the number of pins and applies the roll to the current frame
// or as a bonus if all frames have been completed.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game.
// It returns an error if the game is incomplete or if bonus throws are missing/extra for the tenth frame.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}

// exercises/practice/bowling/.meta/example_test.go
package bowling

import "testing"

// rollTestCase defines a test case for the Roll function.
type rollTestCase struct {
	description   string
	previousRolls []int
	roll          int
	valid         bool
	explainText   string
}

var rollTestCases = []rollTestCase{
	{
		description:   "Valid roll after a series of valid previous rolls",
		previousRolls: []int{3, 4},
		roll:          3,
		valid:         true,
		explainText:   "Should accept valid roll",
	},
	{
		description:   "Invalid roll with wrong pin count",
		previousRolls: []int{3, 4},
		roll:          -1,
		valid:         false,
		explainText:   "Should reject negative pins",
	},
	{
		description:   "Invalid roll exceeding frame limit",
		previousRolls: []int{5, 6},
		roll:          5,
		valid:         false,
		explainText:   "Should reject roll causing frame total to exceed 10",
	},
}

// scoreTestCase defines a test case for the Score function.
type scoreTestCase struct {
	description   string
	previousRolls []int
	score         int
	valid         bool
	explainText   string
}

// perfectGameRolls returns a slice of rolls representing a perfect game (12 strikes).
func perfectGameRolls() []int {
	rolls := []int{}
	for i := 0; i < 12; i++ {
		rolls = append(rolls, 10)
	}
	return rolls
}

var scoreTestCases = []scoreTestCase{
	{
		description:   "Perfect game",
		previousRolls: perfectGameRolls(),
		score:         300,
		valid:         true,
		explainText:   "A perfect game should score 300",
	},
	{
		description:   "Incomplete game",
		previousRolls: []int{10, 10},
		score:         0,
		valid:         false,
		explainText:   "Game is incomplete, should return error",
	},
}

const testPreviousRollErrorMessage = "\n\tUnexpected error occurred: %v\n\twhile applying the previous rolls for the\n\ttest case: %v\n\tThe error was returned from Roll(%d) for previousRolls[%d]."

func applyTestRolls(g *Game, rolls []int) (int, int, error) {
	for index, pins := range rolls {
		if err := g.Roll(pins); err != nil {
			return index, pins, err
		}
	}
	return 0, 0, nil
}

func TestRoll(t *testing.T) {
	for _, tc := range rollTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyTestRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(testPreviousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			err = g.Roll(tc.roll)
			if tc.valid && err != nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v returned unexpected error: %v", tc.roll, tc.previousRolls, err)
			} else if !tc.valid && err == nil {
				t.Fatalf("Roll(%d) after Previous Rolls: %#v expected an error, got nil\n\tExplanation: %s", tc.roll, tc.previousRolls, tc.explainText)
			}
		})
	}
}

func TestScore(t *testing.T) {
	for _, tc := range scoreTestCases {
		t.Run(tc.description, func(t *testing.T) {
			g := NewGame()
			index, pins, err := applyTestRolls(g, tc.previousRolls)
			if err != nil {
				t.Fatalf(testPreviousRollErrorMessage, err, tc.previousRolls, pins, index)
			}
			score, err := g.Score()
			switch {
			case !tc.valid:
				if err == nil {
					t.Fatalf("Score() after Previous Rolls: %#v expected an error, got score %d\n\tExplanation: %s", tc.previousRolls, score, tc.explainText)
				}
			case err != nil:
				t.Fatalf("Score() after Previous Rolls: %#v returned error: %v, want: %d", tc.previousRolls, err, tc.score)
			case score != tc.score:
				t.Fatalf("Score() after Previous Rolls: %#v = %d, want: %d", tc.previousRolls, score, tc.score)
			}
		})
	}
}


=== Test Results (Attempt 9) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling.go:186:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 10 ===
// exercises/practice/bowling/.meta/example.go
package bowling

import "errors"

const MaxFrame = 10

// Frame represents a single frame in a bowling game.
// It tracks the frame index and the pins knocked down in each throw.
type Frame struct {
	Idx    int
	Throws []int
}

// TotalPins returns the total number of pins knocked down in the frame.
func (f *Frame) TotalPins() int {
	total := 0
	for _, pins := range f.Throws {
		total += pins
	}
	return total
}

// IsStrike returns true if the frame is a strike.
func (f *Frame) IsStrike() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 1
}

// IsSpare returns true if the frame is a spare.
func (f *Frame) IsSpare() bool {
	return f.TotalPins() == 10 && len(f.Throws) == 2
}

// IsOpen returns true if the frame is open (not a strike or spare and exactly two throws have been made).
func (f *Frame) IsOpen() bool {
	return f.TotalPins() < 10 && len(f.Throws) == 2
}

// IsClosed returns true if the frame is over (either a strike or two throws have been made).
func (f *Frame) IsClosed() bool {
	return f.TotalPins() == 10 || len(f.Throws) == 2
}

// Throw adds a throw to the frame.
// It returns an error if adding the throw would exceed 10 pins in total for the frame.
func (f *Frame) Throw(pins int) error {
	if f.TotalPins()+pins > 10 {
		return errors.New("a frame's rolls cannot exceed 10")
	}
	f.Throws = append(f.Throws, pins)
	return nil
}

// Score calculates and returns the score for the frame, including bonus from subsequent throws if applicable.
// The nextThrows parameter contains subsequent rolls used for bonus calculation.
func (f *Frame) Score(nextThrows []int) int {
	score := f.TotalPins()
	if f.IsStrike() {
		score += sumInts(nextThrows, 2)
	} else if f.IsSpare() {
		score += sumInts(nextThrows, 1)
	}
	return score
}

// sumInts sums up to 'count' elements from the slice.
// If there are fewer than 'count' elements, it sums whatever is available.
func sumInts(nums []int, count int) int {
	total := 0
	for i := 0; i < count && i < len(nums); i++ {
		total += nums[i]
	}
	return total
}

// Game represents a complete game of bowling.
// It manages the frames, the current frame index, and bonus throws for the tenth frame.
type Game struct {
	currentFrameIdx int
	bonusThrows     []int
	frames          []*Frame
}

// NewGame constructs a new bowling game with 10 frames.
func NewGame() *Game {
	frames := make([]*Frame, MaxFrame)
	for i := 0; i < MaxFrame; i++ {
		frames[i] = &Frame{Idx: i}
	}
	return &Game{
		currentFrameIdx: 0,
		bonusThrows:     []int{},
		frames:          frames,
	}
}

// currentFrame returns the current frame being played.
func (g *Game) currentFrame() *Frame {
	if g.currentFrameIdx < MaxFrame {
		return g.frames[g.currentFrameIdx]
	}
	return nil
}

// nextThrows returns a slice of all subsequent throws starting from the frame after frameIdx
// and then appending bonus throws.
func (g *Game) nextThrows(frameIdx int) []int {
	next := []int{}
	for i := frameIdx + 1; i < MaxFrame; i++ {
		next = append(next, g.frames[i].Throws...)
	}
	next = append(next, g.bonusThrows...)
	return next
}

// rollBonus handles bonus throws after the tenth frame.
// It validates that bonus rolls are allowed based on the tenth frame outcome and their cumulative pins.
func (g *Game) rollBonus(pins int) error {
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsOpen() {
		return errors.New("cannot throw bonus with an open tenth frame")
	}
	
	g.bonusThrows = append(g.bonusThrows, pins)
	
	// Check against invalid fill balls, e.g. [3, 10]
	if len(g.bonusThrows) == 2 && g.bonusThrows[0] != 10 && (g.bonusThrows[0]+g.bonusThrows[1] > 10) {
		return errors.New("invalid fill balls")
	}
	
	// Check if there are more bonus throws than allowed
	if tenthFrame.IsStrike() && len(g.bonusThrows) > 2 {
		return errors.New("wrong number of fill balls when the tenth frame is a strike")
	} else if tenthFrame.IsSpare() && len(g.bonusThrows) > 1 {
		return errors.New("wrong number of fill balls when the tenth frame is a spare")
	}
	
	return nil
}

// Roll records a roll in the game.
// It validates the number of pins and applies the roll to the current frame or as a bonus if all frames have been completed.
func (g *Game) Roll(pins int) error {
	if pins < 0 || pins > 10 {
		return errors.New("invalid pins")
	}

	if g.currentFrameIdx == MaxFrame {
		return g.rollBonus(pins)
	}

	err := g.currentFrame().Throw(pins)
	if err != nil {
		return err
	}

	if g.currentFrame().IsClosed() {
		g.currentFrameIdx++
	}

	return nil
}

// Score calculates the final score for the game.
// It returns an error if the game is incomplete or if bonus throws are missing/extra for the tenth frame.
func (g *Game) Score() (int, error) {
	if g.currentFrameIdx < MaxFrame {
		return 0, errors.New("frame less than 10")
	}
	
	tenthFrame := g.frames[MaxFrame-1]
	if tenthFrame.IsSpare() && len(g.bonusThrows) != 1 {
		return 0, errors.New("one bonus must be rolled when the tenth frame is spare")
	}
	if tenthFrame.IsStrike() && len(g.bonusThrows) != 2 {
		return 0, errors.New("two bonuses must be rolled when the tenth frame is strike")
	}
	
	total := 0
	for _, frame := range g.frames {
		total += frame.Score(g.nextThrows(frame.Idx))
	}
	return total, nil
}


=== Test Results (Attempt 10) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/bowling [build failed]
FAIL

=== STDERR ===
# exercism/bowling [exercism/bowling.test]
./bowling_test.go:21:21: undefined: rollTestCases
./bowling_test.go:39:21: undefined: scoreTestCases


=== FINAL STATUS: FAILED ===