=== Initial Source Code ===
Source file: exercises/practice/binary-search-tree/.meta/example.py
class TreeNode:
    def __init__(self, data, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right

    def __str__(self):
        return f'TreeNode(data={self.data}, left={self.left}, right={self.right})'


class BinarySearchTree:
    def __init__(self, tree_data):
        self.root = None
        for data in tree_data:
            self.add(data)

    def add(self, data):
        if self.root is None:
            self.root = TreeNode(data)
            return
        inserted = False
        cur_node = self.root

        while not inserted:
            if data <= cur_node.data:
                if cur_node.left:
                    cur_node = cur_node.left
                else:
                    cur_node.left = TreeNode(data)
                    inserted = True
            elif data > cur_node.data:
                if cur_node.right:
                    cur_node = cur_node.right
                else:
                    cur_node.right = TreeNode(data)
                    inserted = True

    def _inorder_traverse(self, node, elements):
        if node is not None:
            self._inorder_traverse(node.left, elements)
            elements.append(node.data)
            self._inorder_traverse(node.right, elements)

    def data(self):
        return self.root

    def sorted_data(self):
        elements = []
        self._inorder_traverse(self.root, elements)
        return elements


=== Source Interface ===
class TreeNode:
    def __init__(self, data, left=None, right=None):
        self.data = None
        self.left = None
        self.right = None

    def __str__(self):
        return f'TreeNode(data={self.data}, left={self.left}, right={self.right})'


class BinarySearchTree:
    def __init__(self, tree_data):
        pass

    def data(self):
        pass

    def sorted_data(self):
        pass


=== Target Interface ===
package binarysearchtree

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree.
func NewBst(i int) *BinarySearchTree {
	panic("Please implement the NewBst function")
}

// Insert inserts an int into the BinarySearchTree.
// Inserts happen based on the rules of a binary search tree
func (bst *BinarySearchTree) Insert(i int) {
	panic("Please implement the Insert method")
}

// SortedData returns the ordered contents of BinarySearchTree as an []int.
// The values are in increasing order starting with the lowest int value.
// A BinarySearchTree that has the numbers [1,3,7,5] added will return the
// []int [1,3,5,7].
func (bst *BinarySearchTree) SortedData() []int {
	panic("Please implement the SortedData function")
}


=== Source Test Code ===
# These tests are auto-generated with test data from:
# https://github.com/exercism/problem-specifications/tree/main/exercises/binary-search-tree/canonical-data.json
# File last updated on 2023-07-20

import unittest

from binary_search_tree import (
    BinarySearchTree,
    TreeNode,
)


class BinarySearchTreeTest(unittest.TestCase):
    def test_data_is_retained(self):
        expected = TreeNode("4", None, None)
        self.assertTreeEqual(BinarySearchTree(["4"]).data(), expected)

    def test_smaller_number_at_left_node(self):
        expected = TreeNode("4", TreeNode("2", None, None), None)
        self.assertTreeEqual(BinarySearchTree(["4", "2"]).data(), expected)

    def test_same_number_at_left_node(self):
        expected = TreeNode("4", TreeNode("4", None, None), None)
        self.assertTreeEqual(BinarySearchTree(["4", "4"]).data(), expected)

    def test_greater_number_at_right_node(self):
        expected = TreeNode("4", None, TreeNode("5", None, None))
        self.assertTreeEqual(BinarySearchTree(["4", "5"]).data(), expected)

    def test_can_create_complex_tree(self):
        expected = TreeNode(
            "4",
            TreeNode("2", TreeNode("1", None, None), TreeNode("3", None, None)),
            TreeNode("6", TreeNode("5", None, None), TreeNode("7", None, None)),
        )
        self.assertTreeEqual(
            BinarySearchTree(["4", "2", "6", "1", "3", "5", "7"]).data(), expected
        )

    def test_can_sort_single_number(self):
        expected = ["2"]
        self.assertEqual(BinarySearchTree(["2"]).sorted_data(), expected)

    def test_can_sort_if_second_number_is_smaller_than_first(self):
        expected = ["1", "2"]
        self.assertEqual(BinarySearchTree(["2", "1"]).sorted_data(), expected)

    def test_can_sort_if_second_number_is_same_as_first(self):
        expected = ["2", "2"]
        self.assertEqual(BinarySearchTree(["2", "2"]).sorted_data(), expected)

    def test_can_sort_if_second_number_is_greater_than_first(self):
        expected = ["2", "3"]
        self.assertEqual(BinarySearchTree(["2", "3"]).sorted_data(), expected)

    def test_can_sort_complex_tree(self):
        expected = ["1", "2", "3", "5", "6", "7"]
        self.assertEqual(
            BinarySearchTree(["2", "1", "3", "6", "7", "5"]).sorted_data(), expected
        )

    # Utilities
    def assertTreeEqual(self, tree_one, tree_two):
        try:
            self.compare_tree(tree_one, tree_two)
        except AssertionError:
            raise AssertionError("{} != {}".format(tree_one, tree_two))

    def compare_tree(self, tree_one, tree_two):
        self.assertEqual(tree_one.data, tree_two.data)

        # Compare left tree nodes
        if tree_one.left and tree_two.left:
            self.compare_tree(tree_one.left, tree_two.left)
        elif tree_one.left is None and tree_two.left is None:
            pass
        else:
            raise AssertionError

        # Compare right tree nodes
        if tree_one.right and tree_two.right:
            self.compare_tree(tree_one.right, tree_two.right)
        elif tree_one.right is None and tree_two.right is None:
            pass
        else:
            raise AssertionError


=== Target Test Code ===
package binarysearchtree

import (
	"errors"
	"strings"
	"testing"
)

type DataTestCase struct {
	description string
	input       []int
	paths       []string
	data        []int
}

var newBstTestCase DataTestCase = DataTestCase{
	description: "data is retained",
	input:       []int{4},
	paths:       []string{""},
	data:        []int{4},
}

var insertTestCases = []DataTestCase{
	{
		description: "smaller number at left node",
		input:       []int{4, 2},
		paths:       []string{"", "l"},
		data:        []int{4, 2},
	},
	{
		description: "same number at left node",
		input:       []int{4, 4},
		paths:       []string{"", "l"},
		data:        []int{4, 4},
	},
	{
		description: "greater number at right node",
		input:       []int{4, 5},
		paths:       []string{"", "r"},
		data:        []int{4, 5},
	},
	{
		description: "can create complex tree",
		input:       []int{4, 2, 6, 1, 3, 5, 7},
		paths:       []string{"", "l", "ll", "lr", "r", "rl", "rr"},
		data:        []int{4, 2, 1, 3, 6, 5, 7},
	},
}

type SortedDataTestCase struct {
	description string
	input       []int
	expected    []int
}

var sortedDataTestCases = []SortedDataTestCase{
	{
		description: "can sort single number",
		input:       []int{2},
		expected:    []int{2},
	},
	{
		description: "can sort if second number is smaller than first",
		input:       []int{2, 1},
		expected:    []int{1, 2},
	},
	{
		description: "can sort if second number is same as first",
		input:       []int{2, 2},
		expected:    []int{2, 2},
	},
	{
		description: "can sort if second number is greater than first",
		input:       []int{2, 3},
		expected:    []int{2, 3},
	},
	{
		description: "can sort complex tree",
		input:       []int{2, 1, 3, 6, 7, 5},
		expected:    []int{1, 2, 3, 5, 6, 7},
	},
}

func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	} else {
		return 1 + bst.left.Size() + bst.right.Size()
	}
}

func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		return bst.left.Data(path[1:])
	case 'r':
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}

func slicesEqual(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	if len(a) == 0 {
		return true
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// makeBst builds tree by calling user defined functions NewBst and Insert
func makeBst(input []int) *BinarySearchTree {
	if len(input) == 0 {
		return nil
	}
	result := NewBst(input[0])
	for i := 1; i < len(input); i++ {
		result.Insert(input[i])
	}
	return result
}

func expandPath(p string) string {
	parts := make([]string, len(p))
	for i, c := range p {
		if c == 'l' {
			parts[i] = "left"
		} else {
			parts[i] = "right"
		}
	}
	return strings.Join(append([]string{"bst"}, parts...), ".")
}

func TestNewBst(t *testing.T) {
	td := newBstTestCase
	t.Run(td.description, func(t *testing.T) {
		tree := NewBst(td.input[0])
		if tree == nil {
			t.Fatalf("bst should not be nil")
		}
		if tree.Size() != len(td.input) {
			t.Fatalf("bst should have same number of elements as input, expected: %v, got: %v",
				len(td.input), tree.Size())
		}
		expected := td.data[0]
		got := tree.data
		if got != expected {
			t.Fatalf("expected %d, got %d", expected, got)
		}
	})
}

func TestInsert(t *testing.T) {
	for _, td := range insertTestCases {
		t.Run(td.description, func(t *testing.T) {
			tree := makeBst(td.input)
			if tree == nil {
				t.Fatalf("bst should not be nil")
			}
			if tree.Size() != len(td.input) {
				t.Fatalf("bst should have same number of elements as input, expected: %v, got: %v",
					len(td.input), tree.Size())
			}
			for i, path := range td.paths {
				expected := td.data[i]
				expPath := expandPath(path)
				got, err := tree.Data([]rune(path))
				if err != nil {
					t.Fatalf("%v should not be nil:", expPath)
				}
				if got != expected {
					t.Fatalf("%v: expected %d, got %d", expPath+".data", expected, got)
				}
			}
		})
	}
}

func TestSortedData(t *testing.T) {
	for _, td := range sortedDataTestCases {
		t.Run(td.description, func(t *testing.T) {
			tree := makeBst(td.input)
			if tree == nil {
				t.Fatalf("bst should not be nil")
			}
			if tree.Size() != len(td.input) {
				t.Fatalf("bst should have same number of elements as input, expected: %v, got: %v",
					len(td.input), tree.Size())
			}
			got := tree.SortedData()
			if !slicesEqual(got, td.expected) {
				t.Fatalf("expected %d, got %d", td.expected, got)
			}
		})
	}
}

var benchmarkResult []int

func BenchmarkSortedData(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	input := []int{2, 1, 3, 6, 7, 5, 2, 1, 3, 6, 7, 5}
	tree := makeBst(input)
	var result []int
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		result = tree.SortedData()
	}
	benchmarkResult = result
}


=== Initial Translation ===
// exercises/practice/binary-search-tree/.meta/example.go
package meta

import (
	"fmt"
)

// TreeNode represents a node in the binary search tree.
// It holds an integer data and pointers to left and right child nodes.
// The String method is used to format the TreeNode as a string.
type TreeNode struct {
	Data  int
	Left  *TreeNode
	Right *TreeNode
}

// String returns a string representation of the TreeNode.
func (n *TreeNode) String() string {
	if n == nil {
		return "nil"
	}
	return fmt.Sprintf("TreeNode(data=%d, left=%v, right=%v)", n.Data, n.Left, n.Right)
}

// BinarySearchTree represents a binary search tree with a pointer to the root TreeNode.
type BinarySearchTree struct {
	Root *TreeNode
}

// NewBinarySearchTree creates a new BinarySearchTree with the provided treeData.
// It inserts each element of treeData into the tree using the Add method.
func NewBinarySearchTree(treeData []int) *BinarySearchTree {
	bst := &BinarySearchTree{Root: nil}
	for _, data := range treeData {
		bst.Add(data)
	}
	return bst
}

// Add inserts a new integer into the binary search tree.
// It follows BST insertion rules: left subtree for values less than or equal to current node and right subtree for greater values.
func (bst *BinarySearchTree) Add(data int) {
	if bst.Root == nil {
		bst.Root = &TreeNode{Data: data}
		return
	}

	current := bst.Root
	for {
		if data <= current.Data {
			if current.Left != nil {
				current = current.Left
			} else {
				current.Left = &TreeNode{Data: data}
				break
			}
		} else { // data > current.Data
			if current.Right != nil {
				current = current.Right
			} else {
				current.Right = &TreeNode{Data: data}
				break
			}
		}
	}
}

// Data returns the root of the binary search tree.
func (bst *BinarySearchTree) Data() *TreeNode {
	return bst.Root
}

// SortedData returns the elements of the binary search tree in ascending order.
// It performs an in-order traversal of the tree to gather sorted data.
func (bst *BinarySearchTree) SortedData() []int {
	var elements []int
	var inorderTraverse func(node *TreeNode)
	inorderTraverse = func(node *TreeNode) {
		if node != nil {
			inorderTraverse(node.Left)
			elements = append(elements, node.Data)
			inorderTraverse(node.Right)
		}
	}
	inorderTraverse(bst.Root)
	return elements
}

// Example usage of the BinarySearchTree implementation.
func main() {
	// Example: Creating a BST with initial data and printing its sorted order
	data := []int{7, 3, 9, 1, 5}
	tree := NewBinarySearchTree(data)
	fmt.Println("Sorted Data:", tree.SortedData())
	fmt.Println("Tree Structure:", tree.Data())
}


=== Initial Test Results ===
Return code: 1
=== STDOUT ===

=== STDERR ===
found packages meta (binary_search_tree.go) and binarysearchtree (binary_search_tree_test.go) in /private/var/folders/gy/0zbg6hg95tq8_gy1dnr3tknm0000gn/T/tmpt_h86ptc/sandbox/exercises/practice/binary-search-tree


=== Retry Attempt 1 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import (
	"errors"
)

// BinarySearchTree represents a node in a binary search tree.
// It contains an integer value and pointers to left and right subtrees.
// Note: The BST is built such that values less than or equal to the current node go to the left; values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{
		data: i,
	}
}

// Insert inserts an integer into the BinarySearchTree according to binary search tree rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order by performing an in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	leftSize, rightSize := 0, 0
	if bst.left != nil {
		leftSize = bst.left.Size()
	}
	if bst.right != nil {
		rightSize = bst.right.Size()
	}
	return 1 + leftSize + rightSize
}

// Data returns the data of the node at the end of the given path in the tree.
// The path is represented as a slice of runes where 'l' means go to the left child and 'r' means go to the right child.
// It returns an error if an invalid path is provided.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element: " + string(path[0]))
	}
}

// exercises/practice/binary-search-tree/.meta/example_test.go
package binarysearchtree

import (
	"strings"
	"testing"
	"errors"
)

// DataTestCase holds test cases for tree construction and path evaluation.
// It is used to support the tests for NewBst and Insert.

type DataTestCase struct {
	description string
	input       []int
	paths       []string
	data        []int
}

var newBstTestCase = DataTestCase{
	description: "data is retained",
	input:       []int{4},
	paths:       []string{""},
	data:        []int{4},
}

var insertTestCases = []DataTestCase{
	{
		description: "smaller number at left node",
		input:       []int{4, 2},
		paths:       []string{"", "l"},
		data:        []int{4, 2},
	},
	{
		description: "same number at left node",
		input:       []int{4, 4},
		paths:       []string{"", "l"},
		data:        []int{4, 4},
	},
	{
		description: "greater number at right node",
		input:       []int{4, 5},
		paths:       []string{"", "r"},
		data:        []int{4, 5},
	},
	{
		description: "can create complex tree",
		input:       []int{4, 2, 6, 1, 3, 5, 7},
		paths:       []string{"", "l", "ll", "lr", "r", "rl", "rr"},
		data:        []int{4, 2, 1, 3, 6, 5, 7},
	},
}

// SortedDataTestCase holds test cases for verifying the SortedData output.

type SortedDataTestCase struct {
	description string
	input       []int
	expected    []int
}

var sortedDataTestCases = []SortedDataTestCase{
	{
		description: "can sort single number",
		input:       []int{2},
		expected:    []int{2},
	},
	{
		description: "can sort if second number is smaller than first",
		input:       []int{2, 1},
		expected:    []int{1, 2},
	},
	{
		description: "can sort if second number is same as first",
		input:       []int{2, 2},
		expected:    []int{2, 2},
	},
	{
		description: "can sort if second number is greater than first",
		input:       []int{2, 3},
		expected:    []int{2, 3},
	},
	{
		description: "can sort complex tree",
		input:       []int{2, 1, 3, 6, 7, 5},
		expected:    []int{1, 2, 3, 5, 6, 7},
	},
}

// slicesEqual checks whether two slices of integers are equal.
func slicesEqual(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// makeBst builds a binary search tree by inserting each element from the input slice using NewBst and Insert.
func makeBst(input []int) *BinarySearchTree {
	if len(input) == 0 {
		return nil
	}
	result := NewBst(input[0])
	for i := 1; i < len(input); i++ {
		result.Insert(input[i])
	}
	return result
}

// expandPath converts a path string (composed of 'l' and 'r') into a human-readable format.
// For example, "lr" becomes "bst.left.right".
func expandPath(p string) string {
	parts := make([]string, len(p))
	for i, c := range p {
		if c == 'l' {
			parts[i] = "left"
		} else {
			parts[i] = "right"
		}
	}
	return strings.Join(append([]string{"bst"}, parts...), ".")
}

func TestNewBst(t *testing.T) {
	td := newBstTestCase
	t.Run(td.description, func(t *testing.T) {
		tree := NewBst(td.input[0])
		if tree == nil {
			t.Errorf("NewBst returned nil")
		}
		// Even though the tree has only one node, we expect Size() to be 1
		if tree.Size() != len(td.input) {
			t.Errorf("Expected tree size %v, got %v", len(td.input), tree.Size())
		}
		expected := td.data[0]
		got := tree.data
		if got != expected {
			t.Errorf("Expected data %d, got %d", expected, got)
		}
	})
}

func TestInsert(t *testing.T) {
	for _, td := range insertTestCases {
		t.Run(td.description, func(t *testing.T) {
			tree := makeBst(td.input)
			if tree == nil {
				t.Errorf("NewBst returned nil")
			}
			if tree.Size() != len(td.input) {
				t.Errorf("Expected tree size %v, got %v", len(td.input), tree.Size())
			}
			for i, path := range td.paths {
				expected := td.data[i]
				expPath := expandPath(path)
				got, err := tree.Data([]rune(path))
				if err != nil {
					t.Errorf("%v should not be nil: %v", expPath, err)
				}
				if got != expected {
					t.Errorf("%v: expected %d, got %d", expPath+".data", expected, got)
				}
			}
		})
	}
}

func TestSortedData(t *testing.T) {
	for _, td := range sortedDataTestCases {
		t.Run(td.description, func(t *testing.T) {
			tree := makeBst(td.input)
			if tree == nil {
				t.Errorf("NewBst returned nil")
			}
			if tree.Size() != len(td.input) {
				t.Errorf("Expected tree size %v, got %v", len(td.input), tree.Size())
			}
			got := tree.SortedData()
			if !slicesEqual(got, td.expected) {
				t.Errorf("Expected sorted data %v, got %v", td.expected, got)
			}
		})
	}
}

var benchmarkResult []int

func BenchmarkSortedData(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	input := []int{2, 1, 3, 6, 7, 5, 2, 1, 3, 6, 7, 5}
	tree := makeBst(input)
	var result []int
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		result = tree.SortedData()
	}
	benchmarkResult = result
}


=== Test Results (Attempt 1) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree.go:103:1: syntax error: non-declaration statement outside function body


=== Retry Attempt 2 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 2) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== Retry Attempt 3 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 3) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== Retry Attempt 4 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 4) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== Retry Attempt 5 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 5) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== Retry Attempt 6 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 6) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== Retry Attempt 7 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 7) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== Retry Attempt 8 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 8) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== Retry Attempt 9 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 9) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== Retry Attempt 10 ===
// exercises/practice/binary-search-tree/.meta/example.go
package binarysearchtree

import "errors"

// BinarySearchTree represents a node in a binary search tree.
// It stores an integer value and has pointers to left and right subtrees.
// Insertion rules: values less than or equal to the current node go to the left;
// values greater go to the right.

type BinarySearchTree struct {
	left  *BinarySearchTree
	data  int
	right *BinarySearchTree
}

// NewBst creates and returns a new BinarySearchTree with the given integer as its data.
func NewBst(i int) *BinarySearchTree {
	return &BinarySearchTree{data: i}
}

// Insert inserts an integer into the BinarySearchTree according to BST rules.
func (bst *BinarySearchTree) Insert(i int) {
	if bst == nil {
		return
	}
	if i <= bst.data {
		if bst.left == nil {
			bst.left = NewBst(i)
		} else {
			bst.left.Insert(i)
		}
	} else { // i > bst.data
		if bst.right == nil {
			bst.right = NewBst(i)
		} else {
			bst.right.Insert(i)
		}
	}
}

// SortedData returns the elements of the BinarySearchTree in ascending order using in-order traversal.
func (bst *BinarySearchTree) SortedData() []int {
	var result []int
	if bst == nil {
		return result
	}
	if bst.left != nil {
		result = append(result, bst.left.SortedData()...)
	}
	result = append(result, bst.data)
	if bst.right != nil {
		result = append(result, bst.right.SortedData()...)
	}
	return result
}

// Size returns the total number of nodes in the BinarySearchTree.
func (bst *BinarySearchTree) Size() int {
	if bst == nil {
		return 0
	}
	lSize, rSize := 0, 0
	if bst.left != nil {
		lSize = bst.left.Size()
	}
	if bst.right != nil {
		rSize = bst.right.Size()
	}
	return 1 + lSize + rSize
}

// Data traverses the BinarySearchTree following the given path (as a slice of runes) and returns the data
// stored at that node. 'l' means move to the left child and 'r' to the right child.
// Returns an error if the path is invalid or leads to a nil child.
func (bst *BinarySearchTree) Data(path []rune) (int, error) {
	if bst == nil {
		return 0, errors.New("nil")
	}
	if len(path) == 0 {
		return bst.data, nil
	}
	switch path[0] {
	case 'l':
		if bst.left == nil {
			return 0, errors.New("left child is nil")
		}
		return bst.left.Data(path[1:])
	case 'r':
		if bst.right == nil {
			return 0, errors.New("right child is nil")
		}
		return bst.right.Data(path[1:])
	default:
		return 0, errors.New("Invalid path element:" + string(path[0]))
	}
}


=== Test Results (Attempt 10) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/binary-search-tree [build failed]
FAIL

=== STDERR ===
# exercism/binary-search-tree [exercism/binary-search-tree.test]
./binary_search_tree_test.go:84:30: BinarySearchTree.Size redeclared in this block
	./binary_search_tree.go:59:30: other declaration of Size
./binary_search_tree_test.go:92:30: BinarySearchTree.Data redeclared in this block
	./binary_search_tree.go:76:30: other declaration of Data


=== FINAL STATUS: FAILED ===