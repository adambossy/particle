=== Initial Source Code ===
Source file: exercises/practice/ledger/.meta/example.py
# -*- coding: utf-8 -*-
from datetime import datetime

ROW_FMT = '{{:<{1}}} | {{:<{2}}} | {{:{0}{3}}}'


def truncate(s, length=25):
    if len(s) <= length:
        return s
    return s[:length - 3] + '...'


class LCInfo:
    def __init__(self, locale, currency, columns):
        self.columns = columns
        if locale == 'en_US':
            headers = ['Date', 'Description', 'Change']
            self.datefmt = '{0.month:02}/{0.day:02}/{0.year:04}'
            self.cur_fmt = '{}{}{}{}'
            self.lead_neg = '('
            self.trail_neg = ')'
            self.thousands = ','
            self.decimal = '.'
        elif locale == 'nl_NL':
            headers = ['Datum', 'Omschrijving', 'Verandering']
            self.datefmt = '{0.day:02}-{0.month:02}-{0.year:04}'
            self.cur_fmt = '{1} {0}{2}{3}'
            self.lead_neg = '-'
            self.trail_neg = ' '
            self.thousands = '.'
            self.decimal = ','
        fmt = ROW_FMT.format('<', *columns)
        self.headers = fmt.format(*headers)
        self.cur_symbol = {
            'USD': '$',
            'EUR': '€',
        }.get(currency)

    def number(self, n):
        n_int, n_float = divmod(abs(n), 100)
        n_int_parts = []
        while n_int > 0:
            n_int, idx = divmod(n_int, 1000)
            n_int_parts.insert(0, str(idx))
        return '{}{}{:02}'.format(
            self.thousands.join(n_int_parts) or '0',
            self.decimal,
            n_float,
        )

    def currency(self, change):
        return self.cur_fmt.format(
            self.lead_neg if change < 0 else '',
            self.cur_symbol,
            self.number(change),
            self.trail_neg if change < 0 else ' ',
        )

    def entry(self, entry):
        date, change, desc = entry
        fmt = ROW_FMT.format('>', *self.columns)
        return fmt.format(
            self.datefmt.format(date),
            truncate(desc),
            self.currency(change),
        )

    def table(self, entries):
        lines = [self.headers]
        lines.extend(map(self.entry, sorted(entries)))
        return '\n'.join(lines)


def create_entry(date, description, change):
    return (
        datetime.strptime(date, '%Y-%m-%d'),
        change,
        description
    )


def format_entries(currency, locale, entries):
    columns = (10, 25, 13)
    lcinfo = LCInfo(locale, currency, columns)
    return lcinfo.table(entries)


=== Source Interface ===
# -*- coding: utf-8 -*-
from datetime import datetime


class LedgerEntry:
    def __init__(self):
        self.date = None
        self.description = None
        self.change = None


def create_entry(date, description, change):
    entry = LedgerEntry()
    entry.date = datetime.strptime(date, '%Y-%m-%d')
    entry.description = description
    entry.change = change
    return entry


def format_entries(currency, locale, entries):
    if locale == 'en_US':
        # Generate Header Row
        table = 'Date'
        for _ in range(7):
            table += ' '
        table += '| Description'
        for _ in range(15):
            table += ' '
        table += '| Change'
        for _ in range(7):
            table += ' '

        while len(entries) > 0:
            table += '\n'

            # Find next entry in order
            min_entry_index = -1
            for i in range(len(entries)):
                entry = entries[i]
                if min_entry_index < 0:
                    min_entry_index = i
                    continue
                min_entry = entries[min_entry_index]
                if entry.date < min_entry.date:
                    min_entry_index = i
                    continue
                if (
                    entry.date == min_entry.date and
                    entry.change < min_entry.change
                ):
                    min_entry_index = i
                    continue
                if (
                    entry.date == min_entry.date and
                    entry.change == min_entry.change and
                    entry.description < min_entry.description
                ):
                    min_entry_index = i
                    continue
            entry = entries[min_entry_index]
            entries.pop(min_entry_index)

            # Write entry date to table
            month = entry.date.month
            month = str(month)
            if len(month) < 2:
                month = '0' + month
            date_str = month
            date_str += '/'
            day = entry.date.day
            day = str(day)
            if len(day) < 2:
                day = '0' + day
            date_str += day
            date_str += '/'
            year = entry.date.year
            year = str(year)
            while len(year) < 4:
                year = '0' + year
            date_str += year
            table += date_str
            table += ' | '

            # Write entry description to table
            # Truncate if necessary
            if len(entry.description) > 25:
                for i in range(22):
                    table += entry.description[i]
                table += '...'
            else:
                for i in range(25):
                    if len(entry.description) > i:
                        table += entry.description[i]
                    else:
                        table += ' '
            table += ' | '

            # Write entry change to table
            if currency == 'USD':
                change_str = ''
                if entry.change < 0:
                    change_str = '('
                change_str += '$'
                change_dollar = abs(int(entry.change / 100.0))
                dollar_parts = []
                while change_dollar > 0:
                    dollar_parts.insert(0, str(change_dollar % 1000))
                    change_dollar = change_dollar // 1000
                if len(dollar_parts) == 0:
                    change_str += '0'
                else:
                    while True:
                        change_str += dollar_parts[0]
                        dollar_parts.pop(0)
                        if len(dollar_parts) == 0:
                            break
                        change_str += ','
                change_str += '.'
                change_cents = abs(entry.change) % 100
                change_cents = str(change_cents)
                if len(change_cents) < 2:
                    change_cents = '0' + change_cents
                change_str += change_cents
                if entry.change < 0:
                    change_str += ')'
                else:
                    change_str += ' '
                while len(change_str) < 13:
                    change_str = ' ' + change_str
                table += change_str
            elif currency == 'EUR':
                change_str = ''
                if entry.change < 0:
                    change_str = '('
                change_str += u'€'
                change_euro = abs(int(entry.change / 100.0))
                euro_parts = []
                while change_euro > 0:
                    euro_parts.insert(0, str(change_euro % 1000))
                    change_euro = change_euro // 1000
                if len(euro_parts) == 0:
                    change_str += '0'
                else:
                    while True:
                        change_str += euro_parts[0]
                        euro_parts.pop(0)
                        if len(euro_parts) == 0:
                            break
                        change_str += ','
                change_str += '.'
                change_cents = abs(entry.change) % 100
                change_cents = str(change_cents)
                if len(change_cents) < 2:
                    change_cents = '0' + change_cents
                change_str += change_cents
                if entry.change < 0:
                    change_str += ')'
                else:
                    change_str += ' '
                while len(change_str) < 13:
                    change_str = ' ' + change_str
                table += change_str
        return table
    elif locale == 'nl_NL':
        # Generate Header Row
        table = 'Datum'
        for _ in range(6):
            table += ' '
        table += '| Omschrijving'
        for _ in range(14):
            table += ' '
        table += '| Verandering'
        for _ in range(2):
            table += ' '

        while len(entries) > 0:
            table += '\n'

            # Find next entry in order
            min_entry_index = -1
            for i in range(len(entries)):
                entry = entries[i]
                if min_entry_index < 0:
                    min_entry_index = i
                    continue
                min_entry = entries[min_entry_index]
                if entry.date < min_entry.date:
                    min_entry_index = i
                    continue
                if (
                    entry.date == min_entry.date and
                    entry.change < min_entry.change
                ):
                    min_entry_index = i
                    continue
                if (
                    entry.date == min_entry.date and
                    entry.change == min_entry.change and
                    entry.description < min_entry.description
                ):
                    min_entry_index = i
                    continue
            entry = entries[min_entry_index]
            entries.pop(min_entry_index)

            # Write entry date to table
            day = entry.date.day
            day = str(day)
            if len(day) < 2:
                day = '0' + day
            date_str = day
            date_str += '-'
            month = entry.date.month
            month = str(month)
            if len(month) < 2:
                month = '0' + month
            date_str += month
            date_str += '-'
            year = entry.date.year
            year = str(year)
            while len(year) < 4:
                year = '0' + year
            date_str += year
            table += date_str
            table += ' | '

            # Write entry description to table
            # Truncate if necessary
            if len(entry.description) > 25:
                for i in range(22):
                    table += entry.description[i]
                table += '...'
            else:
                for i in range(25):
                    if len(entry.description) > i:
                        table += entry.description[i]
                    else:
                        table += ' '
            table += ' | '

            # Write entry change to table
            if currency == 'USD':
                change_str = '$ '
                if entry.change < 0:
                    change_str += '-'
                change_dollar = abs(int(entry.change / 100.0))
                dollar_parts = []
                while change_dollar > 0:
                    dollar_parts.insert(0, str(change_dollar % 1000))
                    change_dollar = change_dollar // 1000
                if len(dollar_parts) == 0:
                    change_str += '0'
                else:
                    while True:
                        change_str += dollar_parts[0]
                        dollar_parts.pop(0)
                        if len(dollar_parts) == 0:
                            break
                        change_str += '.'
                change_str += ','
                change_cents = abs(entry.change) % 100
                change_cents = str(change_cents)
                if len(change_cents) < 2:
                    change_cents = '0' + change_cents
                change_str += change_cents
                change_str += ' '
                while len(change_str) < 13:
                    change_str = ' ' + change_str
                table += change_str
            elif currency == 'EUR':
                change_str = u'€ '
                if entry.change < 0:
                    change_str += '-'
                change_euro = abs(int(entry.change / 100.0))
                euro_parts = []
                while change_euro > 0:
                    euro_parts.insert(0, str(change_euro % 1000))
                    change_euro = change_euro // 1000
                if len(euro_parts) == 0:
                    change_str += '0'
                else:
                    while True:
                        change_str += euro_parts[0]
                        euro_parts.pop(0)
                        if len(euro_parts) == 0:
                            break
                        change_str += '.'
                change_str += ','
                change_cents = abs(entry.change) % 100
                change_cents = str(change_cents)
                if len(change_cents) < 2:
                    change_cents = '0' + change_cents
                change_str += change_cents
                change_str += ' '
                while len(change_str) < 13:
                    change_str = ' ' + change_str
                table += change_str
        return table



=== Target Interface ===
package ledger

import (
	"errors"
	"strconv"
	"strings"
)

type Entry struct {
	Date        string // "Y-m-d"
	Description string
	Change      int // in cents
}

func FormatLedger(currency string, locale string, entries []Entry) (string, error) {
	var entriesCopy []Entry
	for _, e := range entries {
		entriesCopy = append(entriesCopy, e)
	}
	if len(entries) == 0 {
		if _, err := FormatLedger(currency, "en-US", []Entry{{Date: "2014-01-01", Description: "", Change: 0}}); err != nil {
			return "", err
		}
	}
	m1 := map[bool]int{true: 0, false: 1}
	m2 := map[bool]int{true: -1, false: 1}
	es := entriesCopy
	for len(es) > 1 {
		first, rest := es[0], es[1:]
		success := false
		for !success {
			success = true
			for i, e := range rest {
				if (m1[e.Date == first.Date]*m2[e.Date < first.Date]*4 +
					m1[e.Description == first.Description]*m2[e.Description < first.Description]*2 +
					m1[e.Change == first.Change]*m2[e.Change < first.Change]*1) < 0 {
					es[0], es[i+1] = es[i+1], es[0]
					success = false
				}
			}
		}
		es = es[1:]
	}

	var s string
	if locale == "nl-NL" {
		s = "Datum" +
			strings.Repeat(" ", 10-len("Datum")) +
			" | " +
			"Omschrijving" +
			strings.Repeat(" ", 25-len("Omschrijving")) +
			" | " + "Verandering" + "\n"
	} else if locale == "en-US" {
		s = "Date" +
			strings.Repeat(" ", 10-len("Date")) +
			" | " +
			"Description" +
			strings.Repeat(" ", 25-len("Description")) +
			" | " + "Change" + "\n"
	} else {
		return "", errors.New("")
	}
	// Parallelism, always a great idea
	co := make(chan struct {
		i int
		s string
		e error
	})
	for i, et := range entriesCopy {
		go func(i int, entry Entry) {
			if len(entry.Date) != 10 {
				co <- struct {
					i int
					s string
					e error
				}{e: errors.New("")}
			}
			d1, d2, d3, d4, d5 := entry.Date[0:4], entry.Date[4], entry.Date[5:7], entry.Date[7], entry.Date[8:10]
			if d2 != '-' {
				co <- struct {
					i int
					s string
					e error
				}{e: errors.New("")}
			}
			if d4 != '-' {
				co <- struct {
					i int
					s string
					e error
				}{e: errors.New("")}
			}
			de := entry.Description
			if len(de) > 25 {
				de = de[:22] + "..."
			} else {
				de = de + strings.Repeat(" ", 25-len(de))
			}
			var d string
			if locale == "nl-NL" {
				d = d5 + "-" + d3 + "-" + d1
			} else if locale == "en-US" {
				d = d3 + "/" + d5 + "/" + d1
			}
			negative := false
			cents := entry.Change
			if cents < 0 {
				cents = cents * -1
				negative = true
			}
			var a string
			if locale == "nl-NL" {
				if currency == "EUR" {
					a += "€"
				} else if currency == "USD" {
					a += "$"
				} else {
					co <- struct {
						i int
						s string
						e error
					}{e: errors.New("")}
				}
				a += " "
				centsStr := strconv.Itoa(cents)
				switch len(centsStr) {
				case 1:
					centsStr = "00" + centsStr
				case 2:
					centsStr = "0" + centsStr
				}
				rest := centsStr[:len(centsStr)-2]
				var parts []string
				for len(rest) > 3 {
					parts = append(parts, rest[len(rest)-3:])
					rest = rest[:len(rest)-3]
				}
				if len(rest) > 0 {
					parts = append(parts, rest)
				}
				for i := len(parts) - 1; i >= 0; i-- {
					a += parts[i] + "."
				}
				a = a[:len(a)-1]
				a += ","
				a += centsStr[len(centsStr)-2:]
				if negative {
					a += "-"
				} else {
					a += " "
				}
			} else if locale == "en-US" {
				if negative {
					a += "("
				}
				if currency == "EUR" {
					a += "€"
				} else if currency == "USD" {
					a += "$"
				} else {
					co <- struct {
						i int
						s string
						e error
					}{e: errors.New("")}
				}
				centsStr := strconv.Itoa(cents)
				switch len(centsStr) {
				case 1:
					centsStr = "00" + centsStr
				case 2:
					centsStr = "0" + centsStr
				}
				rest := centsStr[:len(centsStr)-2]
				var parts []string
				for len(rest) > 3 {
					parts = append(parts, rest[len(rest)-3:])
					rest = rest[:len(rest)-3]
				}
				if len(rest) > 0 {
					parts = append(parts, rest)
				}
				for i := len(parts) - 1; i >= 0; i-- {
					a += parts[i] + ","
				}
				a = a[:len(a)-1]
				a += "."
				a += centsStr[len(centsStr)-2:]
				if negative {
					a += ")"
				} else {
					a += " "
				}
			} else {
				co <- struct {
					i int
					s string
					e error
				}{e: errors.New("")}
			}
			var al int
			for range a {
				al++
			}
			co <- struct {
				i int
				s string
				e error
			}{i: i, s: d + strings.Repeat(" ", 10-len(d)) + " | " + de + " | " +
				strings.Repeat(" ", 13-al) + a + "\n"}
		}(i, et)
	}
	ss := make([]string, len(entriesCopy))
	for range entriesCopy {
		v := <-co
		if v.e != nil {
			return "", v.e
		}
		ss[v.i] = v.s
	}
	for i := 0; i < len(entriesCopy); i++ {
		s += ss[i]
	}
	return s, nil
}


=== Source Test Code ===
# These tests are auto-generated with test data from:
# https://github.com/exercism/problem-specifications/tree/main/exercises/ledger/canonical-data.json
# File last updated on 2023-12-27

import unittest

from ledger import (
    format_entries,
    create_entry,
)


class LedgerTest(unittest.TestCase):
    maxDiff = 5000

    def test_empty_ledger(self):
        currency = "USD"
        locale = "en_US"
        entries = []
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_one_entry(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Buy present", -1000),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Buy present               |      ($10.00)",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_credit_and_debit(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-02", "Get present", 1000),
            create_entry("2015-01-01", "Buy present", -1000),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Buy present               |      ($10.00)",
                "01/02/2015 | Get present               |       $10.00 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_final_order_tie_breaker_is_change(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Something", 0),
            create_entry("2015-01-01", "Something", -1),
            create_entry("2015-01-01", "Something", 1),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Something                 |       ($0.01)",
                "01/01/2015 | Something                 |        $0.00 ",
                "01/01/2015 | Something                 |        $0.01 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_overlong_description_is_truncated(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Freude schoner Gotterfunken", -123456),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_euros(self):
        currency = "EUR"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Buy present", -1000),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Buy present               |      (€10.00)",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_dutch_locale(self):
        currency = "USD"
        locale = "nl_NL"
        entries = [
            create_entry("2015-03-12", "Buy present", 123456),
        ]
        expected = "\n".join(
            [
                "Datum      | Omschrijving              | Verandering  ",
                "12-03-2015 | Buy present               |   $ 1.234,56 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_dutch_locale_and_euros(self):
        currency = "EUR"
        locale = "nl_NL"
        entries = [
            create_entry("2015-03-12", "Buy present", 123456),
        ]
        expected = "\n".join(
            [
                "Datum      | Omschrijving              | Verandering  ",
                "12-03-2015 | Buy present               |   € 1.234,56 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_dutch_negative_number_with_3_digits_before_decimal_point(self):
        currency = "USD"
        locale = "nl_NL"
        entries = [
            create_entry("2015-03-12", "Buy present", -12345),
        ]
        expected = "\n".join(
            [
                "Datum      | Omschrijving              | Verandering  ",
                "12-03-2015 | Buy present               |    $ -123,45 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_american_negative_number_with_3_digits_before_decimal_point(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-03-12", "Buy present", -12345),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "03/12/2015 | Buy present               |     ($123.45)",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)

    def test_multiple_entries_on_same_date_ordered_by_description(self):
        currency = "USD"
        locale = "en_US"
        entries = [
            create_entry("2015-01-01", "Get present", 1000),
            create_entry("2015-01-01", "Buy present", -1000),
        ]
        expected = "\n".join(
            [
                "Date       | Description               | Change       ",
                "01/01/2015 | Buy present               |      ($10.00)",
                "01/01/2015 | Get present               |       $10.00 ",
            ]
        )
        self.assertEqual(format_entries(currency, locale, entries), expected)


=== Target Test Code ===
package ledger

import (
	"reflect"
	"testing"
)

var successTestCases = []struct {
	name     string
	currency string
	locale   string
	entries  []Entry
	expected string
}{
	{
		name:     "empty ledger",
		currency: "USD",
		locale:   "en-US",
		entries:  nil,
		expected: `
Date       | Description               | Change
`,
	},
	{
		name:     "one entry",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Buy present",
				Change:      -1000,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Buy present               |      ($10.00)
`,
	},
	{
		name:     "credit and debit",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-02",
				Description: "Get present",
				Change:      1000,
			},
			{
				Date:        "2015-01-01",
				Description: "Buy present",
				Change:      -1000,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Buy present               |      ($10.00)
01/02/2015 | Get present               |       $10.00 
`,
	},
	{
		name:     "multiple entries on same date ordered by description",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Buy present",
				Change:      -1000,
			},
			{
				Date:        "2015-01-01",
				Description: "Get present",
				Change:      1000,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Buy present               |      ($10.00)
01/01/2015 | Get present               |       $10.00 
`,
	},
	{
		name:     "final order tie breaker is change",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Something",
				Change:      0,
			},
			{
				Date:        "2015-01-01",
				Description: "Something",
				Change:      -1,
			},
			{
				Date:        "2015-01-01",
				Description: "Something",
				Change:      1,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Something                 |       ($0.01)
01/01/2015 | Something                 |        $0.00 
01/01/2015 | Something                 |        $0.01 
`,
	},
	{
		name:     "overlong descriptions",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Freude schoner Gotterfunken",
				Change:      -123456,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
`,
	},
	{
		name:     "euros",
		currency: "EUR",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-01-01",
				Description: "Buy present",
				Change:      -1000,
			},
		},
		expected: `
Date       | Description               | Change
01/01/2015 | Buy present               |      (€10.00)
`,
	},
	{
		name:     "Dutch locale",
		currency: "USD",
		locale:   "nl-NL",
		entries: []Entry{
			{
				Date:        "2015-03-12",
				Description: "Buy present",
				Change:      123456,
			},
		},
		expected: `
Datum      | Omschrijving              | Verandering
12-03-2015 | Buy present               |   $ 1.234,56 
`,
	},
	{
		name:     "Dutch negative number with 3 digits before decimal point",
		currency: "USD",
		locale:   "nl-NL",
		entries: []Entry{
			{
				Date:        "2015-03-12",
				Description: "Buy present",
				Change:      -12345,
			},
		},
		expected: `
Datum      | Omschrijving              | Verandering
12-03-2015 | Buy present               |     $ 123,45-
`,
	},
	{
		name:     "American negative number with 3 digits before decimal point",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-03-12",
				Description: "Buy present",
				Change:      -12345,
			},
		},
		expected: `
Date       | Description               | Change
03/12/2015 | Buy present               |     ($123.45)
`,
	},
}

var failureTestCases = []struct {
	name     string
	currency string
	locale   string
	entries  []Entry
}{
	{
		name:     "empty currency",
		currency: "",
		locale:   "en-US",
		entries:  nil,
	},
	{
		name:     "invalid currency",
		currency: "ABC",
		locale:   "en-US",
		entries:  nil,
	},
	{
		name:     "empty locale",
		currency: "USD",
		locale:   "",
		entries:  nil,
	},
	{
		name:     "invalid locale",
		currency: "USD",
		locale:   "nl-US",
		entries:  nil,
	},
	{
		name:     "invalid date (way too high month)",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-131-11",
				Description: "Buy present",
				Change:      12345,
			},
		},
	},
	{
		name:     "invalid date (wrong separator)",
		currency: "USD",
		locale:   "en-US",
		entries: []Entry{
			{
				Date:        "2015-12/11",
				Description: "Buy present",
				Change:      12345,
			},
		},
	},
}

func TestFormatLedgerSuccess(t *testing.T) {
	for _, tc := range successTestCases {
		t.Run(tc.name, func(t *testing.T) {
			actual, err := FormatLedger(tc.currency, tc.locale, tc.entries)
			if err != nil {
				t.Fatalf("FormatLedger for input named %q returned unexpected error %v", tc.name, err)
			}
			expected := tc.expected[1:] // Strip initial newline
			if actual != expected {
				t.Fatalf("FormatLedger for input named %q failed\ngot:\n%s\nwant:\n%s", tc.name, actual, expected)
			}
		})
	}
}

func TestFormatLedgerFailure(t *testing.T) {
	for _, tt := range failureTestCases {
		t.Run(tt.name, func(t *testing.T) {
			_, err := FormatLedger(tt.currency, tt.locale, tt.entries)
			if err == nil {
				t.Fatalf("FormatLedger for input %q expected error, got nil", tt.name)
			}
		})
	}
}

func TestFormatLedgerNotChangeInput(t *testing.T) {
	entries := []Entry{
		{
			Date:        "2015-01-02",
			Description: "Freude schöner Götterfunken",
			Change:      1000,
		},
		{
			Date:        "2015-01-01",
			Description: "Buy present",
			Change:      -1000,
		},
	}
	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)
	FormatLedger("USD", "en-US", entries)
	if !reflect.DeepEqual(entries, entriesCopy) {
		t.Fatalf("FormatLedger modifies the input entries array")
	}
}

func BenchmarkFormatLedger(b *testing.B) {
	if testing.Short() {
		b.Skip("skipping benchmark in short mode.")
	}
	for i := 0; i < b.N; i++ {
		for _, tt := range successTestCases {
			FormatLedger(tt.currency, tt.locale, tt.entries)
		}
	}
}


=== Initial Translation ===
// exercises/practice/ledger/.meta/example.go
package ledger

import (
	"strings"
	"time"
)

const rowFmt = "{{:<{1}}} | {{:<{2}}} | {{:{0}{3}}}"

func truncate(s string, length int) string {
	if len(s) <= length {
		return s
	}
	return s[:length-3] + "..."
}

type LCInfo struct {
	columns    []int
	headers    string
	datefmt    string
	cur_fmt    string
	lead_neg   string
	trail_neg  string
	thousands  string
	decimal    string
	cur_symbol string
}

func NewLCInfo(locale, currency string, columns []int) *LCInfo {
	info := &LCInfo{columns: columns}
	if locale == "en_US" {
		headers := []string{"Date", "Description", "Change"}
		info.datefmt = "{0.month:02}/{0.day:02}/{0.year:04}"
		info.cur_fmt = "{}{}{}{}"
		info.lead_neg = "("
		info.trail_neg = ")"
		info.thousands = ","
		info.decimal = "."
	} else if locale == "nl_NL" {
		headers := []string{"Datum", "Omschrijving", "Verandering"}
		info.datefmt = "{0.day:02}-{0.month:02}-{0.year:04}"
		info.cur_fmt = "{1} {0}{2}{3}"
		info.lead_neg = "-"
		info.trail_neg = " "
		info.thousands = "."
		info.decimal = ","
	}
	fmt := strings.Replace(rowFmt, "{1}", strconv.Itoa(columns[0]), 1)
	fmt = strings.Replace(fmt, "{2}", strconv.Itoa(columns[1]), 1)
	fmt = strings.Replace(fmt, "{3}", strconv.Itoa(columns[2]), 1)
	info.headers = fmt
	info.cur_symbol = map[string]string{"USD": "$", "EUR": "€"}[currency]
	return info
}

func (info *LCInfo) number(n int) string {
	nInt, nFloat := n/100, n%100
	nIntParts := []string{}
	for nInt > 0 {
		nInt, idx := nInt/1000, nInt%1000
		nIntParts = append([]string{strconv.Itoa(idx)}, nIntParts...)
	}
	return strings.Join(nIntParts, info.thousands) + info.decimal + fmt.Sprintf("%02d", nFloat)
}

func (info *LCInfo) currency(change int) string {
	return fmt.Sprintf(info.cur_fmt, info.lead_neg, info.cur_symbol, info.number(change), info.trail_neg)
}

func (info *LCInfo) entry(entry [3]interface{}) string {
	date := entry[0].(time.Time)
	change := entry[1].(int)
	desc := entry[2].(string)
	fmt := strings.Replace(rowFmt, "{1}", strconv.Itoa(info.columns[0]), 1)
	fmt = strings.Replace(fmt, "{2}", strconv.Itoa(info.columns[1]), 1)
	fmt = strings.Replace(fmt, "{3}", strconv.Itoa(info.columns[2]), 1)
	return fmt.Sprintf(fmt, info.datefmt, truncate(desc), info.currency(change))
}

func (info *LCInfo) table(entries [][3]interface{}) string {
	lines := []string{info.headers}
	for _, entry := range entries {
		lines = append(lines, info.entry(entry))
	}
	return strings.Join(lines, "\n")
}

func CreateEntry(date string, description string, change int) [3]interface{} {
	t, _ := time.Parse("2006-01-02", date)
	return [3]interface{}{t, change, description}
}

func FormatEntries(currency, locale string, entries [][3]interface{}) string {
	columns := []int{10, 25, 13}
	info := NewLCInfo(locale, currency, columns)
	return info.table(entries)
}


=== Initial Test Results ===
Return code: 2
=== STDOUT ===
FAIL	exercism/ledger [build failed]
FAIL

=== STDERR ===
# exercism/ledger [exercism/ledger.test]
./ledger_test.go:12:13: undefined: Entry
./ledger_test.go:28:14: undefined: Entry
./ledger_test.go:44:14: undefined: Entry
./ledger_test.go:66:14: undefined: Entry
./ledger_test.go:88:14: undefined: Entry
./ledger_test.go:116:14: undefined: Entry
./ledger_test.go:132:14: undefined: Entry
./ledger_test.go:148:14: undefined: Entry
./ledger_test.go:164:14: undefined: Entry
./ledger_test.go:180:14: undefined: Entry
./ledger_test.go:180:14: too many errors


=== Retry Attempt 1 ===
// exercises/practice/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

const rowFmt = "{{:<{1}}} | {{:<{2}}} | {{:{0}{3}}}"

type Entry struct {
	Date        string
	Description string
	Change      int
}

type header struct {
	Date        string
	Description string
	Change      string
}

type localeInfo struct {
	datefmt    string
	curFmt     string
	leadNeg    string
	trailNeg   string
	thousands  string
	decimal    string
	headers    header
	curSymbol string
}

func newLocaleInfo(locale, currency string) (*localeInfo, error) {
	var info localeInfo
	switch locale {
	case "en-US":
		info.datefmt = "01/02/2006"
		info.curFmt = "%s%s%s%s"
		info.leadNeg = "("
		info.trailNeg = ")"
		info.thousands = ","
		info.decimal = "."
		info.headers = header{
			Date:        "Date",
			Description: "Description",
			Change:      "Change",
		}
	case "nl-NL":
		info.datefmt = "02-01-2006"
		info.curFmt = "%s %s%s%s"
		info.leadNeg = "-"
		info.trailNeg = " "
		info.thousands = "."
		info.decimal = ","
		info.headers = header{
			Date:        "Datum",
			Description: "Omschrijving",
			Change:      "Verandering",
		}
	default:
		return nil, errors.New("invalid locale")
	}
	switch currency {
	case "USD":
		info.curSymbol = "$"
	case "EUR":
		info.curSymbol = "€"
	default:
		return nil, errors.New("invalid currency")
	}
	return &info, nil
}

func (info *localeInfo) formatChange(change int) string {
	cents := abs(change) % 100
	dollars := abs(change) / 100
	dollarParts := []string{}
	for dollars > 0 {
		dollarParts = append([]string{fmt.Sprintf("%03d", dollars%1000)}, dollarParts...)
		dollars /= 1000
	}
	if len(dollarParts) == 0 {
		dollarParts = append(dollarParts, "0")
	}
	changeStr := fmt.Sprintf(info.curFmt,
		info.leadNeg,
		info.curSymbol,
		strings.Join(dollarParts, info.thousands)+info.decimal+fmt.Sprintf("%02d", cents),
		info.trailNeg,
	)
	return strings.TrimSpace(changeStr)
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func validateDate(date string) error {
	if len(date) != 10 {
		return errors.New("invalid date format")
	}
	if date[4] != '-' || date[7] != '-' {
		return errors.New("invalid date format")
	}
	_, err := time.Parse("2006-01-02", date)
	return err
}

func FormatLedger(currency string, locale string, entries []Entry) (string, error) {
	info, err := newLocaleInfo(locale, currency)
	if err != nil {
		return "", err
	}

	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	sort.SliceStable(entriesCopy, func(i, j int) bool {
		return entriesCompare(entriesCopy[i], entriesCopy[j]) < 0
	})

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("%10s | %25s | %13s\n",
		info.headers.Date,
		info.headers.Description,
		info.headers.Change))

	for _, entry := range entriesCopy {
		if err := validateDate(entry.Date); err != nil {
			return "", err
		}
		t, err := time.Parse("2006-01-02", entry.Date)
		if err != nil {
			return "", err
		}

		description := truncate(entry.Description, 25)
		changeStr := info.formatChange(entry.Change)

		sb.WriteString(fmt.Sprintf("%10s | %25s | %13s\n",
			t.Format(info.datefmt),
			description,
			changeStr))
	}

	return sb.String(), nil
}

func truncate(s string, length int) string {
	if len(s) <= length {
		return s
	}
	return s[:length-3] + "..."
}

func entriesCompare(a, b Entry) int {
	dateA, err := time.Parse("2006-01-02", a.Date)
	if err != nil {
		panic(err)
	}
	dateB, err := time.Parse("2006-01-02", b.Date)
	if err != nil {
		panic(err)
	}
	switch {
	case dateA.Before(dateB):
		return -1
	case dateA.After(dateB):
		return 1
	}
	switch {
	case a.Change < b.Change:
		return -1
	case a.Change > b.Change:
		return 1
	}
	return strings.Compare(a.Description, b.Description)
}


=== Test Results (Attempt 1) ===
Return code: 2
=== STDOUT ===
FAIL	exercism/ledger [build failed]
FAIL

=== STDERR ===
# exercism/ledger [exercism/ledger.test]
./ledger.go:8:2: imported and not used: "strconv"


=== Retry Attempt 2 ===
// exercises/practice/ledger/ledger.go
package ledger

import (
	"errors"
	"fmt"
	"sort"
	"strings"
	"time"
)

const rowFmt = "{{:<{1}}} | {{:<{2}}} | {{:{0}{3}}}"

type Entry struct {
	Date        string
	Description string
	Change      int
}

type header struct {
	Date        string
	Description string
	Change      string
}

type localeInfo struct {
	datefmt    string
	curFmt     string
	leadNeg    string
	trailNeg   string
	thousands  string
	decimal    string
	headers    header
	curSymbol string
}

func newLocaleInfo(locale, currency string) (*localeInfo, error) {
	var info localeInfo
	switch locale {
	case "en-US":
		info.datefmt = "01/02/2006"
		info.curFmt = "%s%s%s%s"
		info.leadNeg = "("
		info.trailNeg = ")"
		info.thousands = ","
		info.decimal = "."
		info.headers = header{
			Date:        "Date",
			Description: "Description",
			Change:      "Change",
		}
	case "nl-NL":
		info.datefmt = "02-01-2006"
		info.curFmt = "%s %s%s%s"
		info.leadNeg = "-"
		info.trailNeg = " "
		info.thousands = "."
		info.decimal = ","
		info.headers = header{
			Date:        "Datum",
			Description: "Omschrijving",
			Change:      "Verandering",
		}
	default:
		return nil, errors.New("invalid locale")
	}
	switch currency {
	case "USD":
		info.curSymbol = "$"
	case "EUR":
		info.curSymbol = "€"
	default:
		return nil, errors.New("invalid currency")
	}
	return &info, nil
}

func (info *localeInfo) formatChange(change int) string {
	cents := abs(change) % 100
	dollars := abs(change) / 100
	dollarParts := []string{}
	for dollars > 0 {
		dollarParts = append([]string{fmt.Sprintf("%03d", dollars%1000)}, dollarParts...)
		dollars /= 1000
	}
	if len(dollarParts) == 0 {
		dollarParts = append(dollarParts, "0")
	}
	changeStr := fmt.Sprintf(info.curFmt,
		info.leadNeg,
		info.curSymbol,
		strings.Join(dollarParts, info.thousands)+info.decimal+fmt.Sprintf("%02d", cents),
		info.trailNeg,
	)
	return strings.TrimSpace(changeStr)
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func validateDate(date string) error {
	if len(date) != 10 {
		return errors.New("invalid date format")
	}
	if date[4] != '-' || date[7] != '-' {
		return errors.New("invalid date format")
	}
	_, err := time.Parse("2006-01-02", date)
	return err
}

func FormatLedger(currency string, locale string, entries []Entry) (string, error) {
	info, err := newLocaleInfo(locale, currency)
	if err != nil {
		return "", err
	}

	entriesCopy := make([]Entry, len(entries))
	copy(entriesCopy, entries)

	sort.SliceStable(entriesCopy, func(i, j int) bool {
		return entriesCompare(entriesCopy[i], entriesCopy[j]) < 0
	})

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("%10s | %25s | %13s\n",
		info.headers.Date,
		info.headers.Description,
		info.headers.Change))

	for _, entry := range entriesCopy {
		if err := validateDate(entry.Date); err != nil {
			return "", err
		}
		t, err := time.Parse("2006-01-02", entry.Date)
		if err != nil {
			return "", err
		}

		description := truncate(entry.Description, 25)
		changeStr := info.formatChange(entry.Change)

		sb.WriteString(fmt.Sprintf("%10s | %25s | %13s\n",
			t.Format(info.datefmt),
			description,
			changeStr))
	}

	return sb.String(), nil
}

func truncate(s string, length int) string {
	if len(s) <= length {
		return s
	}
	return s[:length-3] + "..."
}

func entriesCompare(a, b Entry) int {
	dateA, err := time.Parse("2006-01-02", a.Date)
	if err != nil {
		panic(err)
	}
	dateB, err := time.Parse("2006-01-02", b.Date)
	if err != nil {
		panic(err)
	}
	switch {
	case dateA.Before(dateB):
		return -1
	case dateA.After(dateB):
		return 1
	}
	switch {
	case a.Change < b.Change:
		return -1
	case a.Change > b.Change:
		return 1
	}
	return strings.Compare(a.Description, b.Description)
}


=== Test Results (Attempt 2) ===
Return code: 1
=== STDOUT ===
--- FAIL: TestFormatLedgerSuccess (0.00s)
    --- FAIL: TestFormatLedgerSuccess/empty_ledger (0.00s)
        ledger_test.go:259: FormatLedger for input named "empty ledger" failed
            got:
                  Date |               Description |        Change
            
            want:
            Date       | Description               | Change
    --- FAIL: TestFormatLedgerSuccess/one_entry (0.00s)
        ledger_test.go:259: FormatLedger for input named "one entry" failed
            got:
                  Date |               Description |        Change
            01/01/2015 |               Buy present |     ($010.00)
            
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
    --- FAIL: TestFormatLedgerSuccess/credit_and_debit (0.00s)
        ledger_test.go:259: FormatLedger for input named "credit and debit" failed
            got:
                  Date |               Description |        Change
            01/01/2015 |               Buy present |     ($010.00)
            01/02/2015 |               Get present |     ($010.00)
            
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/02/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/multiple_entries_on_same_date_ordered_by_description (0.00s)
        ledger_test.go:259: FormatLedger for input named "multiple entries on same date ordered by description" failed
            got:
                  Date |               Description |        Change
            01/01/2015 |               Buy present |     ($010.00)
            01/01/2015 |               Get present |     ($010.00)
            
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      ($10.00)
            01/01/2015 | Get present               |       $10.00 
    --- FAIL: TestFormatLedgerSuccess/final_order_tie_breaker_is_change (0.00s)
        ledger_test.go:259: FormatLedger for input named "final order tie breaker is change" failed
            got:
                  Date |               Description |        Change
            01/01/2015 |                 Something |       ($0.01)
            01/01/2015 |                 Something |       ($0.00)
            01/01/2015 |                 Something |       ($0.01)
            
            want:
            Date       | Description               | Change
            01/01/2015 | Something                 |       ($0.01)
            01/01/2015 | Something                 |        $0.00 
            01/01/2015 | Something                 |        $0.01 
    --- FAIL: TestFormatLedgerSuccess/overlong_descriptions (0.00s)
        ledger_test.go:259: FormatLedger for input named "overlong descriptions" failed
            got:
                  Date |               Description |        Change
            01/01/2015 | Freude schoner Gotterf... | ($001,234.56)
            
            want:
            Date       | Description               | Change
            01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)
    --- FAIL: TestFormatLedgerSuccess/euros (0.00s)
        ledger_test.go:259: FormatLedger for input named "euros" failed
            got:
                  Date |               Description |        Change
            01/01/2015 |               Buy present |     (€010.00)
            
            want:
            Date       | Description               | Change
            01/01/2015 | Buy present               |      (€10.00)
    --- FAIL: TestFormatLedgerSuccess/Dutch_locale (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch locale" failed
            got:
                 Datum |              Omschrijving |   Verandering
            12-03-2015 |               Buy present | - $001.234,56
            
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |   $ 1.234,56 
    --- FAIL: TestFormatLedgerSuccess/Dutch_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "Dutch negative number with 3 digits before decimal point" failed
            got:
                 Datum |              Omschrijving |   Verandering
            12-03-2015 |               Buy present |     - $123,45
            
            want:
            Datum      | Omschrijving              | Verandering
            12-03-2015 | Buy present               |     $ 123,45-
    --- FAIL: TestFormatLedgerSuccess/American_negative_number_with_3_digits_before_decimal_point (0.00s)
        ledger_test.go:259: FormatLedger for input named "American negative number with 3 digits before decimal point" failed
            got:
                  Date |               Description |        Change
            03/12/2015 |               Buy present |     ($123.45)
            
            want:
            Date       | Description               | Change
            03/12/2015 | Buy present               |     ($123.45)
FAIL
FAIL	exercism/ledger	0.280s
FAIL

=== STDERR ===


=== ERROR ===
Error processing sample (returncode=1): 

=== FINAL STATUS: ERROR ===